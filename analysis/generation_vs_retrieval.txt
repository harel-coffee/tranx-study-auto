
###########
QUERY:print current date time

GENERATED (& CHOSEN) SNIPPET:
print(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'))

SNIPPET:
for date in mylist :
    print str(date)

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
print today.strftime('We are the %d, %b %Y')
>>> 'We are the 22, Nov 2008'

SNIPPET:
import datetime
mylist = []
today = datetime.date.today()
mylist.append(today)
print mylist[0] # print the date object, not the container ;-)
2008-11-22

# It's better to always use str() because :

print "This is a new day : ", mylist[0] # will work
>>> This is a new day : 2008-11-22

print "This is a new day : " + mylist[0] # will crash
>>> cannot concatenate 'str' and 'datetime.date' objects

print "This is a new day : " + str(mylist[0]) 
>>> This is a new day : 2008-11-22

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

CONALA MATCH:
datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

CONALA MATCH:
datetime.datetime.now()

###########
QUERY:get date time one week from now

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.combine(datetime.date.today(), datetime.timedelta(days=12))

SNIPPET:
from datetime import datetime
datetime.now().strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
>>> import datetime
>>> datetime.datetime.today()
datetime.datetime(2012, 3, 23, 23, 24, 55, 173504)
>>> datetime.datetime.today().weekday()
4

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
from datetime import datetime, timedelta

d = datetime.today() - timedelta(days=days_to_subtract)

###########
QUERY:write to csv file

GENERATED (& CHOSEN) SNIPPET:
writer.writerow(file)

SNIPPET:
Color,Number
red,22
blue,10

SNIPPET:
import csv

with open("output.csv", "wb") as f:
    writer = csv.writer(f)
    writer.writerows(a)

SNIPPET:
df.to_csv(file_name, sep='\t', encoding='utf-8')

SNIPPET:
,Color,Number
0,red,22
1,blue,10

SNIPPET:
Color  Number
0   red     22
1  blue     10

SNIPPET:
df.to_csv(file_name, sep='\t')

SNIPPET:
##text=List of strings to be written to file
with open('csvfile.csv','wb') as file:
    for line in text:
        file.write(line)
        file.write('\n')

SNIPPET:
df.to_csv(file_name, encoding='utf-8', index=False)

SNIPPET:
import csv

with open("out.csv", "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerows(a)

###########
QUERY:recursively iterate over all files in a directory

GENERATED (& CHOSEN) SNIPPET:
for dirname, dirnames, filenames in os.walk('file.txt'):
    for subdirname in dirnames:
        print(os.path.join(dirname, subdirname))
    for filename in filenames:
        pass

SNIPPET:
import os

directory = os.fsencode(directory_in_str)

for file in os.listdir(directory):
     filename = os.fsdecode(file)
     if filename.endswith(".asm") or filename.endswith(".py"): 
         # print(os.path.join(directory, filename))
         continue
     else:
         continue

SNIPPET:
for root, subdirs, files in os.walk(rootdir):

SNIPPET:
from pathlib import Path

pathlist = Path(directory_in_str).glob('**/*.asm')
for path in pathlist:
     # because path is object not string
     path_in_str = str(path)
     # print(path_in_str)

SNIPPET:
import os
import sys

walk_dir = sys.argv[1]

print('walk_dir = ' + walk_dir)

# If your current working directory may change during script execution, it's recommended to
# immediately convert program arguments to an absolute path. Then the variable root below will
# be an absolute path as well. Example:
# walk_dir = os.path.abspath(walk_dir)
print('walk_dir (absolute) = ' + os.path.abspath(walk_dir))

for root, subdirs, files in os.walk(walk_dir):
    print('--\nroot = ' + root)
    list_file_path = os.path.join(root, 'my-directory-list.txt')
    print('list_file_path = ' + list_file_path)

    with open(list_file_path, 'wb') as list_file:
        for subdir in subdirs:
            print('\t- subdirectory ' + subdir)

        for filename in files:
            file_path = os.path.join(root, filename)

            print('\t- file %s (full path: %s)' % (filename, file_path))

            with open(file_path, 'rb') as f:
                f_content = f.read()
                list_file.write(('The file %s contains:\n' % filename).encode('utf-8'))
                list_file.write(f_content)
                list_file.write(b'\n')

SNIPPET:
import os

for filename in os.listdir(directory):
    if filename.endswith(".asm") or filename.endswith(".py"): 
         # print(os.path.join(directory, filename))
        continue
    else:
        continue

SNIPPET:
import fnmatch
import os

matches = []
for root, dirnames, filenames in os.walk('src'):
    for filename in fnmatch.filter(filenames, '*.c'):
        matches.append(os.path.join(root, filename))

SNIPPET:
from pathlib import Path

for path in Path('src').rglob('*.c'):
    print(path.name)

###########
QUERY:regex replace capture group

GENERATED (& CHOSEN) SNIPPET:
re.sub('#(\\w+)', '\\1', text)

SNIPPET:
result = re.sub(r"(\d.*?)\s(\d.*?)", r"\1 \2", string1)

SNIPPET:
re.sub(r'(\_a)?\.([^\.]*)$' , r'_suff.\2',"long.file.name.jpg")

SNIPPET:
coord_re = re.sub(r"(\d), (\d)", r"\1,\2", coords)

SNIPPET:
p.sub('gray \\1', s)

SNIPPET:
re.sub(r'(?:_a)?\.([^.]*)$', r'_suff.\1', "long.file.name.jpg")

SNIPPET:
>>> '\1,\2'
'\x01,\x02'
>>> print '\1,\2'
,
>>> print r'\1,\2'   # this is what you actually want
\1,\2

SNIPPET:
p.sub(r'gray \1', s)

###########
QUERY:load csv file with pandas

GENERATED (& CHOSEN) SNIPPET:
pandas.read_csv(file, sep='\t', lineterminator='\r')

SNIPPET:
1.0, 2, 3
4, 5.5, 6

import numpy as np
np.genfromtxt('myfile.csv',delimiter=',')

SNIPPET:
import pandas as pd

url="https://raw.githubusercontent.com/cs109/2014_data/master/countries.csv"
c=pd.read_csv(url)

SNIPPET:
import pandas as pd
df=pd.read_csv('myfile.csv', sep=',',header=None)
df.values
array([[ 1. ,  2. ,  3. ],
       [ 4. ,  5.5,  6. ]])

SNIPPET:
chunksize = 10 ** 6
for chunk in pd.read_csv(filename, chunksize=chunksize):
    process(chunk)

SNIPPET:
array([[ 1. ,  2. ,  3. ],
       [ 4. ,  5.5,  6. ]])

SNIPPET:
from numpy import genfromtxt
my_data = genfromtxt('my_file.csv', delimiter=',')

SNIPPET:
np.genfromtxt('myfile.csv',delimiter=',',dtype=None)

###########
QUERY:get average of row values in pandas dataframe

GENERATED (& CHOSEN) SNIPPET:
df.groupby(np.arange(len(df.columns)) // 2 + 1, axis=1).mean()

SNIPPET:
In [15]: len(test)
Out[15]: 21

In [16]: len(train)
Out[16]: 79

SNIPPET:
from sklearn.model_selection import train_test_split

train, test = train_test_split(df, test_size=0.2)

SNIPPET:
train=df.sample(frac=0.8,random_state=200) #random state is a seed value
test=df.drop(train.index)

SNIPPET:
>>> import pandas as pd
>>> from numpy.random import randint

>>> df = pd.DataFrame(columns=['lib', 'qty1', 'qty2'])
>>> for i in range(5):
>>>     df.loc[i] = ['name' + str(i)] + list(randint(10, size=2))

>>> df
     lib qty1 qty2
0  name0    3    3
1  name1    2    4
2  name2    2    8
3  name3    2    1
4  name4    9    6

SNIPPET:
In [3]: sub_df
Out[3]:
          A         B
2 -0.133653 -0.030854

In [4]: sub_df.iloc[0]
Out[4]:
A   -0.133653
B   -0.030854
Name: 2, dtype: float64

In [5]: sub_df.iloc[0]['A']
Out[5]: -0.13365288513107493

SNIPPET:
rows_list = []
for row in input_rows:

        dict1 = {}
        # get input row in dictionary format
        # key = col_name
        dict1.update(blah..) 

        rows_list.append(dict1)

df = pd.DataFrame(rows_list)

SNIPPET:
In [11]: df = pd.DataFrame(np.random.randn(100, 2))

In [12]: msk = np.random.rand(len(df)) < 0.8

In [13]: train = df[msk]

In [14]: test = df[~msk]

###########
QUERY:pandas join dataframes

GENERATED (& CHOSEN) SNIPPET:
pd.concat([df1, df2], axis=1)

SNIPPET:
left.join(right, on=key_or_keys)
pd.merge(left, right, left_on=key_or_keys, right_index=True, how='left', sort=False)

SNIPPET:
from functools import reduce

SNIPPET:
pd.merge(df1, df2, left_index=True, right_index=True)

SNIPPET:
df_final = reduce(lambda left,right: pd.merge(left,right,on='name'), dfs)

SNIPPET:
import pandas as pd

SNIPPET:
dfs = [df0, df1, df2, dfN]

SNIPPET:
df1.join(df2)

###########
QUERY:save plt figure

GENERATED (& CHOSEN) SNIPPET:
plt.savefig('plt', dpi=1000)

SNIPPET:
plt.savefig('my_fig.png', dpi=my_dpi * 10)

SNIPPET:
plt.savefig('my_fig.png', dpi=my_dpi)

SNIPPET:
from matplotlib import pyplot as plt

plt.savefig('foo.png')
plt.savefig('foo.pdf')

SNIPPET:
savefig('foo.png', bbox_inches='tight')

SNIPPET:
plt.figure(figsize=(800/my_dpi, 800/my_dpi), dpi=my_dpi)

SNIPPET:
import matplotlib.pyplot as plt

f = plt.figure()
plt.plot(range(10), range(10), "o")
plt.show()

f.savefig("foo.pdf", bbox_inches='tight')

SNIPPET:
import matplotlib.pyplot as plt
fig, ax = plt.subplots( nrows=1, ncols=1 )  # create figure & 1 axis
ax.plot([0,1,2], [10,20,3])
fig.savefig('path/to/save/image/to.png')   # save the figure to file
plt.close(fig)    # close the figure window

###########
QUERY:plt create figure with size

GENERATED (& CHOSEN) SNIPPET:
plt.figure(figsize=(3, 4))

SNIPPET:
f, axs = plt.subplots(2,2,figsize=(15,15))

SNIPPET:
fig.set_size_inches(18.5, 10.5, forward=True)

SNIPPET:
from pylab import rcParams
rcParams['figure.figsize'] = 5, 10

SNIPPET:
import matplotlib.pyplot as plt
plt.rcParams["figure.figsize"] = (20,3)

SNIPPET:
fig = matplotlib.pyplot.gcf()
fig.set_size_inches(18.5, 10.5)
fig.savefig('test2png.png', dpi=100)

SNIPPET:
f.set_figheight(15)
f.set_figwidth(15)

SNIPPET:
from matplotlib.pyplot import figure
figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')

CONALA MATCH:
plt.figure(figsize=(3, 4))

CONALA EXACT MATCH:
plt.figure(figsize=(3, 4))

###########
QUERY:group pandas df by two columns

GENERATED (& CHOSEN) SNIPPET:
df.groupby(['A', 'B'], axis=1)

SNIPPET:
In [49]: df
Out[49]: 
          0         1
0  1.000000  0.000000
1 -0.494375  0.570994
2  1.000000  0.000000
3  1.876360 -0.229738
4  1.000000  0.000000

In [50]: def f(x):    
   ....:  return x[0] + x[1]  
   ....:  

In [51]: df.apply(f, axis=1) #passes a Series object, row-wise
Out[51]: 
0    1.000000
1    0.076619
2    1.000000
3    1.646622
4    1.000000

SNIPPET:
ID  col_1  col_2      col_3
0  1      0      1     [a, b]
1  2      2      4  [c, d, e]
2  3      3      5  [d, e, f]

SNIPPET:
df['col_3'] = df.apply(lambda x: f(x.col_1, x.col_2), axis=1)

SNIPPET:
from collections import defaultdict
dic={}
for g in ['male', 'female']:
  dic[g]=defaultdict(dict)
  for y in [2013, 2014]:
    dic[g][y]=df[(df[Gender]==g) & (df[Year]==y)] #store the DataFrames to a dict of dict

SNIPPET:
males = df[(df[Gender]=='Male') & (df[Year]==2014)]

SNIPPET:
df['col_3'] = df.apply(lambda x: f(x['col 1'], x['col 2']), axis=1)

SNIPPET:
import pandas as pd

df = pd.DataFrame({'ID':['1', '2', '3'], 'col_1': [0, 2, 3], 'col_2':[1, 4, 5]})
mylist = ['a', 'b', 'c', 'd', 'e', 'f']

def get_sublist(sta,end):
    return mylist[sta:end+1]

df['col_3'] = df.apply(lambda x: get_sublist(x.col_1, x.col_2), axis=1)

###########
QUERY:random sample with replacement

GENERATED (& CHOSEN) SNIPPET:
random.choice(random.choice(sample), repeat=n)

SNIPPET:
>>> A = np.random.randint(5, size=(10,3))
>>> A
array([[1, 3, 0],
       [3, 2, 0],
       [0, 2, 1],
       [1, 1, 4],
       [3, 2, 2],
       [0, 1, 0],
       [1, 3, 1],
       [0, 4, 1],
       [2, 4, 2],
       [3, 3, 1]])
>>> idx = np.random.randint(10, size=2)
>>> idx
array([7, 6])
>>> A[idx,:]
array([[0, 4, 1],
       [1, 3, 1]])

SNIPPET:
import random
random.sample(range(100), 10)

SNIPPET:
A[np.random.choice(A.shape[0], 2, replace=False), :]

SNIPPET:
A[np.random.randint(A.shape[0], size=2), :]

SNIPPET:
In [11]: df = pd.DataFrame([[1, 2], [3, 4], [5, 6], [7, 8]], columns=["A", "B"])

In [12]: df.sample(2)
Out[12]:
   A  B
0  1  2
2  5  6

In [13]: df.sample(2)
Out[13]:
   A  B
3  7  8
0  1  2

SNIPPET:
all_lines = f1.readlines()
for i in range(50):
    lines = random.sample(all_lines, 40)

SNIPPET:
from random import random
from bisect import bisect

def weighted_choice(choices):
    values, weights = zip(*choices)
    total = 0
    cum_weights = []
    for w in weights:
        total += w
        cum_weights.append(total)
    x = random() * total
    i = bisect(cum_weights, x)
    return values[i]

>>> weighted_choice([("WHITE",90), ("RED",8), ("GREEN",2)])
'WHITE'

SNIPPET:
def weighted_choice(choices):
   total = sum(w for c, w in choices)
   r = random.uniform(0, total)
   upto = 0
   for c, w in choices:
      if upto + w >= r:
         return c
      upto += w
   assert False, "Shouldn't get here"

SNIPPET:
from numpy.random import choice
draw = choice(list_of_candidates, number_of_items_to_pick,
              p=probability_distribution)

SNIPPET:
Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04)
Type 'copyright', 'credits' or 'license' for more information
IPython 6.0.0 -- An enhanced Interactive Python. Type '?' for help.

In [1]: import random

In [2]: random.choices(
...:     population=[['a','b'], ['b','a'], ['c','b']],
...:     weights=[0.2, 0.2, 0.6],
...:     k=10
...: )

Out[2]:
[['c', 'b'],
 ['c', 'b'],
 ['b', 'a'],
 ['c', 'b'],
 ['c', 'b'],
 ['b', 'a'],
 ['c', 'b'],
 ['b', 'a'],
 ['c', 'b'],
 ['c', 'b']]

###########
QUERY:sort dict by key

GENERATED (& CHOSEN) SNIPPET:
sorted(list(dict.items()), key=lambda x: x[1])

SNIPPET:
import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(0))

SNIPPET:
from operator import itemgetter
newlist = sorted(list_to_be_sorted, key=itemgetter('name'))

SNIPPET:
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=lambda kv: kv[1])

SNIPPET:
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
{k: v for k, v in sorted(x.items(), key=lambda item: item[1])}
{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}

SNIPPET:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])

SNIPPET:
import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(1))

SNIPPET:
import collections

sorted_dict = collections.OrderedDict(sorted_x)

###########
QUERY:list files in folder

GENERATED (& CHOSEN) SNIPPET:
os.listdir('<unk>')

SNIPPET:
['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]

SNIPPET:
from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break

SNIPPET:
import glob
print(glob.glob("/home/adam/*.txt"))

SNIPPET:
from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]

SNIPPET:
import os
for root, dirs, files in os.walk("/mydir"):
    for file in files:
        if file.endswith(".txt"):
             print(os.path.join(root, file))

SNIPPET:
import glob, os
os.chdir("/mydir")
for file in glob.glob("*.txt"):
    print(file)

SNIPPET:
import os
for file in os.listdir("/mydir"):
    if file.endswith(".txt"):
        print(os.path.join("/mydir", file))

###########
QUERY:move file to other directory

GENERATED (& CHOSEN) SNIPPET:
shutil.copy2('<unk>', '<unk>')

SNIPPET:
>>> import shutil
>>> shutil.move(destination, source)
>>> os.listdir('/opt/awesome/source')
['awesome.txt']

SNIPPET:
in /opt/awesome
○ → ls
source
○ → ls source
awesome.txt

python 
>>> source = '/opt/awesome/source'
>>> destination = '/opt/awesome/destination'
>>> import os
>>> os.rename(source, destination)
>>> os.listdir('/opt/awesome')
['destination']

SNIPPET:
import os
import shutil

os.rename("path/to/current/file.foo", "path/to/new/destination/for/file.foo")
shutil.move("path/to/current/file.foo", "path/to/new/destination/for/file.foo")
os.replace("path/to/current/file.foo", "path/to/new/destination/for/file.foo")

SNIPPET:
import shutil
import os

source = '/path/to/source_folder'
dest1 = '/path/to/dest_folder'

files = os.listdir(source)

for f in files:
    shutil.move(source+f, dest1)

SNIPPET:
from pathlib import Path

Path("path/to/current/file.foo").rename("path/to/new/destination/for/file.foo")

SNIPPET:
import os, shutil
path = "/volume1/Users/Transfer/"
moveto = "/volume1/Users/Drive_Transfer/"
files = os.listdir(path)
files.sort()
for f in files:
    src = path+f
    dst = moveto+f
    shutil.move(src,dst)

SNIPPET:
import os
import shutil

root_src_dir = 'Src Directory\\'
root_dst_dir = 'Dst Directory\\'

for src_dir, dirs, files in os.walk(root_src_dir):
    dst_dir = src_dir.replace(root_src_dir, root_dst_dir, 1)
    if not os.path.exists(dst_dir):
        os.makedirs(dst_dir)
    for file_ in files:
        src_file = os.path.join(src_dir, file_)
        dst_file = os.path.join(dst_dir, file_)
        if os.path.exists(dst_file):
            # in case of the src and dst are the same file
            if os.path.samefile(src_file, dst_file):
                continue
            os.remove(dst_file)
        shutil.move(src_file, dst_dir)

###########
QUERY:print datetime in mm-dd-yyyy hh:mm  format

GENERATED (& CHOSEN) SNIPPET:
time.strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
from datetime import datetime

datetime.today().strftime('%Y-%m-%d')

SNIPPET:
for date in mylist :
    print str(date)

SNIPPET:
print today.strftime('We are the %d, %b %Y')
>>> 'We are the 22, Nov 2008'

SNIPPET:
import datetime
mylist = []
today = datetime.date.today()
mylist.append(today)
print mylist[0] # print the date object, not the container ;-)
2008-11-22

# It's better to always use str() because :

print "This is a new day : ", mylist[0] # will work
>>> This is a new day : 2008-11-22

print "This is a new day : " + mylist[0] # will crash
>>> cannot concatenate 'str' and 'datetime.date' objects

print "This is a new day : " + str(mylist[0]) 
>>> This is a new day : 2008-11-22

SNIPPET:
import datetime
f"{datetime.datetime.now():%Y-%m-%d}"
>>> '2017-06-15'

SNIPPET:
datetime.today().strftime('%Y-%m-%d-%H:%M:%S')

SNIPPET:
print "We are the {:%d, %b %Y}".format(today)
>>> 'We are the 22, Nov 2008'

###########
QUERY:get time now

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.now()

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

MATCH:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
>>> current_milli_time()
1378761833768

SNIPPET:
import time

current_milli_time = lambda: int(round(time.time() * 1000))

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

MATCH:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
import time
millis = int(round(time.time() * 1000))
print millis

CONALA MATCH:
datetime.datetime.now()

CONALA EXACT MATCH:
datetime.datetime.now()

###########
QUERY:copy file `ddd.png`

GENERATED (& CHOSEN) SNIPPET:
shutil.copy2(ddd.png, 'ddd.png')

SNIPPET:
import shutil
shutil.copy('/etc/hostname', '/var/tmp/testhostname')

SNIPPET:
from shutil import copyfile
copyfile(src, dst)

SNIPPET:
shutil.copy(src_file, dest_file, *, follow_symlinks=True)

# example
shutil.copy('source.txt', 'destination.txt')

SNIPPET:
shutil.copyfile(src_file, dest_file, *, follow_symlinks=True)

# example    
shutil.copyfile('source.txt', 'destination.txt')

SNIPPET:
┌──────────────────┬────────┬───────────┬───────┬────────────────┐
│     Function     │ Copies │   Copies  │Can use│   Destination  │
│                  │metadata│permissions│buffer │may be directory│
├──────────────────┼────────┼───────────┼───────┼────────────────┤
│shutil.copy       │   No   │    Yes    │   No  │      Yes       │
│shutil.copyfile   │   No   │     No    │   No  │       No       │
│shutil.copy2      │  Yes   │    Yes    │   No  │      Yes       │
│shutil.copyfileobj│   No   │     No    │  Yes  │       No       │
└──────────────────┴────────┴───────────┴───────┴────────────────┘

SNIPPET:
import os
import shutil
import subprocess

SNIPPET:
import shutil
shutil.copy2('/src/dir/file.ext', '/dst/dir/newname.ext') # complete target filename given
shutil.copy2('/src/file.ext', '/dst/dir') # target filename is /dst/dir/file.ext

###########
QUERY:copy a file to dist

GENERATED (& CHOSEN) SNIPPET:
shutil.copy2(file, 'en_US')

SNIPPET:
import shutil
shutil.copy('/etc/hostname', '/var/tmp/testhostname')

SNIPPET:
from shutil import copyfile
copyfile(src, dst)

SNIPPET:
shutil.copy(src_file, dest_file, *, follow_symlinks=True)

# example
shutil.copy('source.txt', 'destination.txt')

SNIPPET:
shutil.copyfile(src_file, dest_file, *, follow_symlinks=True)

# example    
shutil.copyfile('source.txt', 'destination.txt')

SNIPPET:
┌──────────────────┬────────┬───────────┬───────┬────────────────┐
│     Function     │ Copies │   Copies  │Can use│   Destination  │
│                  │metadata│permissions│buffer │may be directory│
├──────────────────┼────────┼───────────┼───────┼────────────────┤
│shutil.copy       │   No   │    Yes    │   No  │      Yes       │
│shutil.copyfile   │   No   │     No    │   No  │       No       │
│shutil.copy2      │  Yes   │    Yes    │   No  │      Yes       │
│shutil.copyfileobj│   No   │     No    │  Yes  │       No       │
└──────────────────┴────────┴───────────┴───────┴────────────────┘

SNIPPET:
import os
import shutil
import subprocess

SNIPPET:
import shutil
shutil.copy2('/src/dir/file.ext', '/dst/dir/newname.ext') # complete target filename given
shutil.copy2('/src/file.ext', '/dst/dir') # target filename is /dst/dir/file.ext

###########
QUERY:cast a float to two decimals

GENERATED (& CHOSEN) SNIPPET:
float('{0:.2f}'.format(cast))

SNIPPET:
answer = str(round(answer, 2))

SNIPPET:
"{:.2f}".format(5)

SNIPPET:
float("{:.2f}".format(13.949999999999999))

SNIPPET:
>>> x = 13.949999999999999999
>>> x
13.95
>>> g = float("{:.2f}".format(x))
>>> g
13.95
>>> x == g
True
>>> h = round(x, 2)
>>> h
13.95
>>> x == h
True

SNIPPET:
>>> 125650429603636838/(2**53)
13.949999999999999

>>> 234042163/(2**24)
13.949999988079071

>>> a = 13.946
>>> print(a)
13.946
>>> print("%.2f" % a)
13.95
>>> round(a,2)
13.949999999999999
>>> print("%.2f" % round(a, 2))
13.95
>>> print("{:.2f}".format(a))
13.95
>>> print("{:.2f}".format(round(a, 2)))
13.95
>>> print("{:.15f}".format(round(a, 2)))
13.949999999999999

SNIPPET:
"{:.2f}".format(13.949999999999999)

SNIPPET:
>>> round(14.22222223, 2)
14.22

###########
QUERY:cast a list to a dataframe

GENERATED (& CHOSEN) SNIPPET:
pd.DataFrame(values, columns=['R_Number', 'C_Number', 'Avg', 'Std'])

SNIPPET:
df <- data.frame(matrix(unlist(l), nrow=132, byrow=T),stringsAsFactors=FALSE)

SNIPPET:
do.call(rbind.data.frame, your_list)

SNIPPET:
df = pd.DataFrame(table, columns=headers)
df

   Heading1  Heading2
0         1         2
1         3         4

SNIPPET:
import numpy as np
percentile_list = pd.DataFrame(np.column_stack([lst1, lst2, lst3]), 
                               columns=['lst1Title', 'lst2Title', 'lst3Title'])

SNIPPET:
import pandas as pd
lst1 = range(100)
lst2 = range(100)
lst3 = range(100)
percentile_list = pd.DataFrame(
    {'lst1Title': lst1,
     'lst2Title': lst2,
     'lst3Title': lst3
    })

percentile_list
    lst1Title  lst2Title  lst3Title
0          0         0         0
1          1         1         1
2          2         2         2
3          3         3         3
4          4         4         4
5          5         5         5
6          6         6         6
...

SNIPPET:
df['new_col'] = mylist

SNIPPET:
df <- data.frame(matrix(unlist(l), nrow=length(l), byrow=T))

###########
QUERY:create a dataframe from a list

GENERATED (& CHOSEN) SNIPPET:
pd.DataFrame(data, columns=['x', 'y'], axis=1)

SNIPPET:
import pandas as pd
import numpy as np

df = pd.DataFrame({'Type':list('ABBC'), 'Set':list('ZZXY')})
df['color'] = np.where(df['Set']=='Z', 'green', 'red')
print(df)

SNIPPET:
import datetime
import pandas as pd
import numpy as np

todays_date = datetime.datetime.now().date()
index = pd.date_range(todays_date-datetime.timedelta(10), periods=10, freq='D')

columns = ['A','B', 'C']

SNIPPET:
df_ = pd.DataFrame(index=index, columns=columns)
df_ = df_.fillna(0) # with 0s rather than NaNs

SNIPPET:
df['color'] = np.where(df['Set']=='Z', 'green', 'red')

SNIPPET:
Set Type  color
0   Z    A  green
1   Z    B  green
2   X    B    red
3   Y    C    red

SNIPPET:
df = pd.DataFrame({'Type':list('ABBC'), 'Set':list('ZZXY')})
conditions = [
    (df['Set'] == 'Z') & (df['Type'] == 'A'),
    (df['Set'] == 'Z') & (df['Type'] == 'B'),
    (df['Type'] == 'B')]
choices = ['yellow', 'blue', 'purple']
df['color'] = np.select(conditions, choices, default='black')
print(df)

SNIPPET:
Set Type   color
0   Z    A  yellow
1   Z    B    blue
2   X    B  purple
3   Y    C   black

###########
QUERY:sort dataframe `jdf` by `scores`

GENERATED (& CHOSEN) SNIPPET:
jdf.sort_values(by=scores.columns)

SNIPPET:
S = pd.Series(np.random.normal(size=200))
S[~((S-S.mean()).abs() > 3*S.std())]

SNIPPET:
df = pd.DataFrame({'Data':np.random.normal(size=200)})
# example dataset of normally distributed data. 

df[np.abs(df.Data-df.Data.mean()) <= (3*df.Data.std())]
# keep only the ones that are within +3 to -3 standard deviations in the column 'Data'.

df[~(np.abs(df.Data-df.Data.mean()) > (3*df.Data.std()))]
# or if you prefer the other way around

SNIPPET:
df = df.sample(frac=1).reset_index(drop=True)

SNIPPET:
df.sample(frac=1)

SNIPPET:
from sklearn.utils import shuffle
df = shuffle(df)

SNIPPET:
$ python3 -m memory_profiler .\test.py
Filename: .\test.py

Line #    Mem usage    Increment   Line Contents
================================================
     5     68.5 MiB     68.5 MiB   @profile
     6                             def shuffle():
     7    847.8 MiB    779.3 MiB       df = pd.DataFrame(np.random.randn(100, 1000000))
     8    847.9 MiB      0.1 MiB       df = df.sample(frac=1).reset_index(drop=True)

SNIPPET:
df = pd.DataFrame(np.random.randn(100, 3))

from scipy import stats
df[(np.abs(stats.zscore(df)) < 3).all(axis=1)]

###########
QUERY:sort dataframe `jdf` by the values of column 'scores'

GENERATED (& CHOSEN) SNIPPET:
jdf.sort_values(by='scores')

SNIPPET:
print df
   0  Bytes  Client             Ip
0  1      1    1000   192.168.10.2
1  0      0    2000  192.168.10.12
2  2      2     500   192.168.10.4
3  3      3     159  192.168.10.56

print df.nlargest(3, 'Client')
   0  Bytes  Client             Ip
1  0      0    2000  192.168.10.12
0  1      1    1000   192.168.10.2
2  2      2     500   192.168.10.4

SNIPPET:
df1 = df.sort_values('score',ascending = False).groupby('pidx').head(2)
print (df1)

    mainid pidx pidy  score
8        2    x    w     12
4        1    a    e      8
2        1    c    a      7
10       2    y    x      6
1        1    a    c      5
7        2    z    y      5
6        2    y    z      3
3        1    c    b      2
5        2    x    y      1

SNIPPET:
import pandas as pd

df = pd.DataFrame({'a': ['GOTV', 'Persuasion', 'Likely Supporter', 
                         'GOTV', 'Persuasion', 'Persuasion+GOTV']})

df.a = pd.Categorical(df.a, 
                      categories=["Likely Supporter","GOTV","Persuasion","Persuasion+GOTV"],
                      ordered=True)

print (df)
                  a
0              GOTV
1        Persuasion
2  Likely Supporter
3              GOTV
4        Persuasion
5   Persuasion+GOTV

print (df.a)
0                GOTV
1          Persuasion
2    Likely Supporter
3                GOTV
4          Persuasion
5     Persuasion+GOTV
Name: a, dtype: category
Categories (4, object): [Likely Supporter < GOTV < Persuasion < Persuasion+GOTV]

SNIPPET:
In [6]: df.sort('Bytes', ascending=False)
Out[6]:
   0  Bytes      Client Ip
1  1   2000  192.168.10.12
0  0   1000   192.168.10.2
2  2    500   192.168.10.4
3  3    159  192.168.10.56

SNIPPET:
np.random.seed(123)
N = 1000000

L1 = list('abcdefghijklmnopqrstu')
L2 = list('efghijklmnopqrstuvwxyz')
df = pd.DataFrame({'mainid':np.random.randint(1000, size=N),
                   'pidx': np.random.randint(10000, size=N),
                   'pidy': np.random.choice(L2, N),
                   'score':np.random.randint(1000, size=N)})
#print (df)

def epat(df):
    grouped = df.groupby('pidx')
    new_df = pd.DataFrame([], columns = df.columns)
    for key, values in grouped:
        new_df = pd.concat([new_df, grouped.get_group(key).sort_values('score', ascending=True)[:2]], 0)
    return (new_df)

print (epat(df))

In [133]: %timeit (df.sort_values('score',ascending = False).groupby('pidx').head(2))
1 loop, best of 3: 309 ms per loop

In [134]: %timeit (df.set_index(['mainid','pidy']).groupby('pidx')['score'].nlargest(2).reset_index())
1 loop, best of 3: 7.11 s per loop

In [147]: %timeit (epat(df))
1 loop, best of 3: 22 s per loop

SNIPPET:
df = df.set_index(['mainid','pidy']).groupby('pidx')['score'].nlargest(2).reset_index() 
print (df)
  pidx  mainid pidy  score
0    a       1    e      8
1    a       1    c      5
2    c       1    a      7
3    c       1    b      2
4    x       2    w     12
5    x       2    y      1
6    y       2    x      6
7    y       2    z      3
8    z       2    y      5

SNIPPET:
df.sort_values('a', inplace=True)
print (df)
                  a
2  Likely Supporter
0              GOTV
3              GOTV
1        Persuasion
4        Persuasion
5   Persuasion+GOTV

###########
QUERY:datetime

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.strptime('<unk>', '%Y-%m-%dT%H:%M:%S')

SNIPPET:
for date in mylist :
    print str(date)

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
datetime.datetime.now().date()

SNIPPET:
import datetime
mylist = []
today = datetime.date.today()
mylist.append(today)
print mylist[0] # print the date object, not the container ;-)
2008-11-22

# It's better to always use str() because :

print "This is a new day : ", mylist[0] # will work
>>> This is a new day : 2008-11-22

print "This is a new day : " + mylist[0] # will crash
>>> cannot concatenate 'str' and 'datetime.date' objects

print "This is a new day : " + str(mylist[0]) 
>>> This is a new day : 2008-11-22

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

###########
QUERY:time add

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.now().time() + datetime.timedelta(days=1, hours=3)

SNIPPET:
import time

start = time.time()
print("hello")
end = time.time()
print(end - start)

SNIPPET:
date_1 = datetime.datetime.strptime(start_date, "%m/%d/%y")

end_date = date_1 + datetime.timedelta(days=10)

SNIPPET:
import datetime

SNIPPET:
from timeit import default_timer as timer

start = timer()
# ...
end = timer()
print(end - start) # Time in seconds, e.g. 5.38091952400282

SNIPPET:
b = a + datetime.timedelta(seconds=3)

SNIPPET:
import datetime
a = datetime.datetime(100,1,1,11,34,59)
b = a + datetime.timedelta(0,3) # days, seconds, then other fields.
print(a.time())
print(b.time())

SNIPPET:
11:34:59
11:35:02

CONALA MATCH:
datetime.datetime.now()

CONALA MATCH:
datetime.datetime.now().time()

###########
QUERY:copy file

GENERATED (& CHOSEN) SNIPPET:
shutil.copy2(file, 'rb')

SNIPPET:
import shutil
shutil.copy('/etc/hostname', '/var/tmp/testhostname')

SNIPPET:
from shutil import copyfile
copyfile(src, dst)

SNIPPET:
shutil.copyfile(src_file, dest_file, *, follow_symlinks=True)

# example    
shutil.copyfile('source.txt', 'destination.txt')

SNIPPET:
import os
import shutil
src_files = os.listdir(src)
for file_name in src_files:
    full_file_name = os.path.join(src, file_name)
    if os.path.isfile(full_file_name):
        shutil.copy(full_file_name, dest)

SNIPPET:
import shutil, errno

def copyanything(src, dst):
    try:
        shutil.copytree(src, dst)
    except OSError as exc: # python >2.5
        if exc.errno == errno.ENOTDIR:
            shutil.copy(src, dst)
        else: raise

SNIPPET:
┌──────────────────┬────────┬───────────┬───────┬────────────────┐
│     Function     │ Copies │   Copies  │Can use│   Destination  │
│                  │metadata│permissions│buffer │may be directory│
├──────────────────┼────────┼───────────┼───────┼────────────────┤
│shutil.copy       │   No   │    Yes    │   No  │      Yes       │
│shutil.copyfile   │   No   │     No    │   No  │       No       │
│shutil.copy2      │  Yes   │    Yes    │   No  │      Yes       │
│shutil.copyfileobj│   No   │     No    │  Yes  │       No       │
└──────────────────┴────────┴───────────┴───────┴────────────────┘

SNIPPET:
import shutil
shutil.copy2('/src/dir/file.ext', '/dst/dir/newname.ext') # complete target filename given
shutil.copy2('/src/file.ext', '/dst/dir') # target filename is /dst/dir/file.ext

SNIPPET:
import os
import shutil
import subprocess

###########
QUERY:sort key of dict

GENERATED (& CHOSEN) SNIPPET:
sorted(list(dict.items()), key=lambda x: x[1])

SNIPPET:
import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(0))

SNIPPET:
from operator import itemgetter
newlist = sorted(list_to_be_sorted, key=itemgetter('name'))

SNIPPET:
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=lambda kv: kv[1])

SNIPPET:
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
{k: v for k, v in sorted(x.items(), key=lambda item: item[1])}
{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}

SNIPPET:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])

SNIPPET:
import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(1))

SNIPPET:
import collections

sorted_dict = collections.OrderedDict(sorted_x)

###########
QUERY:print list

GENERATED (& CHOSEN) SNIPPET:
print('%s,' % my_list)

SNIPPET:
mylist = ['x', 3, 'b']
print '[%s]' % ', '.join(map(str, mylist))

SNIPPET:
for p in myList: print p

SNIPPET:
from pprint import pprint
pprint(the_list)

SNIPPET:
print(*myList, sep='\n')

SNIPPET:
[x, 3, b]

SNIPPET:
print '\n'.join(str(p) for p in myList)

SNIPPET:
mylist = ['x', 3, 'b']
print('[%s]' % ', '.join(map(str, mylist)))

###########
QUERY:read all files under a folder

GENERATED (& CHOSEN) SNIPPET:
os.listdir('<unk>')

SNIPPET:
['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]

SNIPPET:
from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break

SNIPPET:
import os
 arr = os.listdir()
 print(arr)

 >>> ['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']

SNIPPET:
import glob
print(glob.glob("/home/adam/*.txt"))

SNIPPET:
from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]

SNIPPET:
import glob

mylist = [f for f in glob.glob("*.txt")]

SNIPPET:
import glob

txtfiles = []
for file in glob.glob("*.txt"):
    txtfiles.append(file)

###########
QUERY:open text file

GENERATED (& CHOSEN) SNIPPET:
with open('file.txt', 'r') as f:
    f = f.open('file.txt', 'r', encoding='utf-8')

SNIPPET:
with open('filename') as f:
    lines = [line.rstrip() for line in f]

SNIPPET:
import urllib2

data = urllib2.urlopen("http://www.google.com").read(20000) # read only 20 000 chars
data = data.split("\n") # then split it into lines

for line in data:
    print line

SNIPPET:
# Read in the file
with open('file.txt', 'r') as file :
  filedata = file.read()

# Replace the target string
filedata = filedata.replace('ram', 'abcd')

# Write the file out again
with open('file.txt', 'w') as file:
  file.write(filedata)

SNIPPET:
with open("file.txt") as file_in:
    lines = []
    for line in file_in:
        lines.append(line)

SNIPPET:
import urllib2  # the lib that handles the url stuff

data = urllib2.urlopen(target_url) # it's a file like object and works just like a file
for line in data: # files are iterable
    print line

SNIPPET:
with open('data.txt', 'r') as file:
    data = file.read().replace('\n', '')

SNIPPET:
#!/usr/bin/env python3
import fileinput

with fileinput.FileInput(filename, inplace=True, backup='.bak') as file:
    for line in file:
        print(line.replace(text_to_search, replacement_text), end='')

SNIPPET:
with open(filename) as f:
    content = f.readlines()
# you may also want to remove whitespace characters like `\n` at the end of each line
content = [x.strip() for x in content]

SNIPPET:
with open('filename') as f:
    lines = f.readlines()

SNIPPET:
with open('data.txt', 'r') as myfile:
  data = myfile.read()

SNIPPET:
import urllib2

for line in urllib2.urlopen(target_url):
    print line

###########
QUERY:read csv file

GENERATED (& CHOSEN) SNIPPET:
df = pd.read_csv('myfile.txt', sep=',', header=None)

SNIPPET:
line[0] = ['Year:', 'Dec:', 'Jan:']
line[1] = ['1', '50', '60']
line[2] = ['2', '25', '50']
line[3] = ['3', '30', '30']
line[4] = ['4', '40', '20']
line[5] = ['5', '10', '10']

SNIPPET:
for row in getdata(somefilename, sequence_of_criteria):
    # process row

SNIPPET:
def getdata(filename, criteria):
    for criterion in criteria:
        for row in getstuff(filename, criterion):
            yield row

SNIPPET:
import pandas as pd
print pd.read_csv('value.txt')

        Date    price  factor_1  factor_2
0  2012-06-11  1600.20     1.255     1.548
1  2012-06-12  1610.02     1.258     1.554
2  2012-06-13  1618.07     1.249     1.552
3  2012-06-14  1624.40     1.253     1.556
4  2012-06-15  1626.15     1.258     1.552
5  2012-06-16  1626.15     1.263     1.558
6  2012-06-17  1626.15     1.264     1.572

SNIPPET:
import csv

def getstuff(filename, criterion):
    with open(filename, "rb") as csvfile:
        datareader = csv.reader(csvfile)
        yield next(datareader)  # yield the header row
        count = 0
        for row in datareader:
            if row[3] == criterion:
                yield row
                count += 1
            elif count:
                # done when having read a consecutive series of rows 
                return

SNIPPET:
import csv
from itertools import dropwhile, takewhile

def getstuff(filename, criterion):
    with open(filename, "rb") as csvfile:
        datareader = csv.reader(csvfile)
        yield next(datareader)  # yield the header row
        # first row, plus any subsequent rows that match, then stop
        # reading altogether
        # Python 2: use `for row in takewhile(...): yield row` instead
        # instead of `yield from takewhile(...)`.
        yield from takewhile(
            lambda r: r[3] == criterion,
            dropwhile(lambda r: r[3] != criterion, datareader))
        return

SNIPPET:
import csv

with open("test.csv", "r") as f:
    reader = csv.reader(f, delimiter="\t")
    for i, line in enumerate(reader):
        print 'line[{}] = {}'.format(i, line)

###########
QUERY:pandas to csv

GENERATED (& CHOSEN) SNIPPET:
df.to_csv('<unk>', index=False)

SNIPPET:
df.to_csv(file_name, sep='\t', encoding='utf-8')

SNIPPET:
df.to_csv('my_csv.csv', mode='a', header=False)

SNIPPET:
df.to_csv(file_name, sep='\t')

SNIPPET:
In [1]: df = pd.read_csv('foo.csv', index_col=0)

In [2]: df
Out[2]:
   A  B  C
0  1  2  3
1  4  5  6

In [3]: df + 6
Out[3]:
    A   B   C
0   7   8   9
1  10  11  12

In [4]: with open('foo.csv', 'a') as f:
             (df + 6).to_csv(f, header=False)

SNIPPET:
,A,B,C
0,1,2,3
1,4,5,6
0,7,8,9
1,10,11,12

SNIPPET:
,A,B,C
0,1,2,3
1,4,5,6

SNIPPET:
with open('my_csv.csv', 'a') as f:
    df.to_csv(f, header=False)

###########
QUERY:average by group pandas

GENERATED (& CHOSEN) SNIPPET:
df.groupby(np.arange(len(df.columns)) // 3).mean()

SNIPPET:
In [6]: gb = df.groupby(['col1', 'col2'])
   ...: counts = gb.size().to_frame(name='counts')
   ...: (counts
   ...:  .join(gb.agg({'col3': 'mean'}).rename(columns={'col3': 'col3_mean'}))
   ...:  .join(gb.agg({'col4': 'median'}).rename(columns={'col4': 'col4_median'}))
   ...:  .join(gb.agg({'col4': 'min'}).rename(columns={'col4': 'col4_min'}))
   ...:  .reset_index()
   ...: )
   ...: 
Out[6]: 
  col1 col2  counts  col3_mean  col4_median  col4_min
0    A    B       4  -0.372500       -0.810     -1.32
1    C    D       3  -0.476667       -0.110     -1.65
2    E    F       2   0.455000        0.475     -0.47
3    G    H       1   1.480000       -0.630     -0.63

SNIPPET:
df.groupby(['col1', 'col2']).size().reset_index(name='counts')

SNIPPET:
In [4]: df.groupby(['col1', 'col2']).size().reset_index(name='counts')
Out[4]: 
  col1 col2  counts
0    A    B       4
1    C    D       3
2    E    F       2
3    G    H       1

SNIPPET:
df.groupby(['col1','col2']).size()

SNIPPET:
In [5]: (df
   ...: .groupby(['col1', 'col2'])
   ...: .agg({
   ...:     'col3': ['mean', 'count'], 
   ...:     'col4': ['median', 'min', 'count']
   ...: }))
Out[5]: 
            col4                  col3      
          median   min count      mean count
col1 col2                                   
A    B    -0.810 -1.32     4 -0.372500     4
C    D    -0.110 -1.65     3 -0.476667     3
E    F     0.475 -0.47     2  0.455000     2
G    H    -0.630 -0.63     1  1.480000     1

SNIPPET:
In [3]: df.groupby(['col1', 'col2']).size()
Out[3]: 
col1  col2
A     B       4
C     D       3
E     F       2
G     H       1
dtype: int64

SNIPPET:
In [2]: df
Out[2]: 
  col1 col2  col3  col4  col5  col6
0    A    B  0.20 -0.61 -0.49  1.49
1    A    B -1.53 -1.01 -0.39  1.82
2    A    B -0.44  0.27  0.72  0.11
3    A    B  0.28 -1.32  0.38  0.18
4    C    D  0.12  0.59  0.81  0.66
5    C    D -0.13 -1.65 -1.64  0.50
6    C    D -1.42 -0.11 -0.18 -0.44
7    E    F -0.00  1.42 -0.26  1.17
8    E    F  0.91 -0.47  1.35 -0.34
9    G    H  1.48 -0.63 -1.14  0.17

###########
QUERY:pandas round value

GENERATED (& CHOSEN) SNIPPET:
df.round()

SNIPPET:
df.round(2)
      0     1     2     3
0  0.06  0.67  0.77  0.71
1  0.80  0.56  0.97  0.15
2  0.03  0.59  0.11  0.95
3  0.33  0.19  0.46  0.92

df
          0         1         2         3
0  0.057116  0.669422  0.767117  0.708115
1  0.796867  0.557761  0.965837  0.147157
2  0.029647  0.593893  0.114066  0.950810
3  0.325707  0.193619  0.457812  0.920403

SNIPPET:
In[2]: 
    df.value1 = df.value1.round()
    print df

Out[2]:
    item  value1  value2
    0    a       1     1.3
    1    a       2     2.5
    2    a       0     0.0
    3    b       3    -1.0
    4    b       5    -1.0

SNIPPET:
data.mean().round(0)  # Rounds mean to nearest integer, e.g. 1.95 = 2 and 1.05 = 1

SNIPPET:
In [479]: df
Out[479]: 
         ID  birthyear    weight
0    619040       1962  0.123123
1    600161       1963  0.981742
2  25602033       1963  1.312312
3    624870       1987  0.942120

In [480]: df["weight"].mean()
Out[480]: 0.83982437500000007

SNIPPET:
decimals = 2    
df['column'] = df['column'].apply(lambda x: round(x, decimals))

SNIPPET:
df.round(0).astype(int)

SNIPPET:
data.mean().astype(int)  # Truncates mean to integer, e.g. 1.95 = 1

CONALA MATCH:
df.round()

CONALA EXACT MATCH:
df.round()

###########
QUERY:sort pandas dataframe

GENERATED (& CHOSEN) SNIPPET:
df.sort_values(by='*')

SNIPPET:
final_df = df.sort_values(by=['2'], ascending=False)

SNIPPET:
In [11]: df1 = pd.DataFrame(np.random.randint(1, 5, (10,2)), columns=['a','b'])

In [12]: df1.sort(['a', 'b'], ascending=[True, False])
Out[12]:
   a  b
2  1  4
7  1  3
1  1  2
3  1  2
4  3  2
6  4  4
0  4  3
9  4  3
5  4  1
8  4  1

SNIPPET:
df.sort(['a', 'b'], ascending=[True, False])

SNIPPET:
df1.sort(['a', 'b'], ascending=[True, False], inplace=True)

SNIPPET:
df1 = df1.sort(['a', 'b'], ascending=[True, False])

SNIPPET:
In [18]:
df.sort_values('2')

Out[18]:
        0          1     2
4    85.6    January   1.0
3    95.5   February   2.0
7   104.8      March   3.0
0   354.7      April   4.0
8   283.5        May   5.0
6   238.7       June   6.0
5   152.0       July   7.0
1    55.4     August   8.0
11  212.7  September   9.0
10  249.6    October  10.0
9   278.8   November  11.0
2   176.5   December  12.0

SNIPPET:
df.sort_values(['a', 'b'], ascending=[True, False])

###########
QUERY:rename column pandas

GENERATED (& CHOSEN) SNIPPET:
df.rename(columns={'row': 'row'}, inplace=True)

SNIPPET:
df.columns = ['V', 'W', 'X', 'Y', 'Z']
df

   V  W  X  Y  Z
0  x  x  x  x  x
1  x  x  x  x  x
2  x  x  x  x  x

SNIPPET:
df.rename({'a': 'X', 'b': 'Y'}, axis=1, inplace=True)
df

   X  Y  c  d  e
0  x  x  x  x  x
1  x  x  x  x  x
2  x  x  x  x  x

SNIPPET:
df2 = df.rename({'a': 'X', 'b': 'Y'}, axis=1)  # new method
df2 = df.rename({'a': 'X', 'b': 'Y'}, axis='columns')
df2 = df.rename(columns={'a': 'X', 'b': 'Y'})  # old method  

df2

   X  Y  c  d  e
0  x  x  x  x  x
1  x  x  x  x  x
2  x  x  x  x  x

SNIPPET:
df2 = df.set_axis(['V', 'W', 'X', 'Y', 'Z'], axis=1, inplace=False)
df2

   V  W  X  Y  Z
0  x  x  x  x  x
1  x  x  x  x  x
2  x  x  x  x  x

SNIPPET:
>>> df = pd.DataFrame({'$a':[1,2], '$b': [10,20]})
>>> df.columns = ['a', 'b']
>>> df
   a   b
0  1  10
1  2  20

SNIPPET:
df = pd.DataFrame('x', index=range(3), columns=list('abcde'))
df

   a  b  c  d  e
0  x  x  x  x  x
1  x  x  x  x  x
2  x  x  x  x  x

SNIPPET:
df = df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'})
# Or rename the existing DataFrame (rather than creating a copy) 
df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'}, inplace=True)

###########
QUERY:column to integer pandas

GENERATED (& CHOSEN) SNIPPET:
df.apply(lambda row: int(row), axis=1)

SNIPPET:
# convert all columns of DataFrame
df = df.apply(pd.to_numeric) # convert all columns of DataFrame

# convert just columns "a" and "b"
df[["a", "b"]] = df[["a", "b"]].apply(pd.to_numeric)

SNIPPET:
>>> s = pd.Series(["8", 6, "7.5", 3, "0.9"]) # mixed string and numeric values
>>> s
0      8
1      6
2    7.5
3      3
4    0.9
dtype: object

>>> pd.to_numeric(s) # convert everything to float values
0    8.0
1    6.0
2    7.5
3    3.0
4    0.9
dtype: float64

SNIPPET:
>>> pd.to_numeric(s, errors='ignore')
# the original Series is returned untouched

SNIPPET:
>>> pd.to_numeric(s) # or pd.to_numeric(s, errors='raise')
ValueError: Unable to parse string

SNIPPET:
>>> pd.to_numeric(s, errors='coerce')
0     1.0
1     2.0
2     4.7
3     NaN
4    10.0
dtype: float64

SNIPPET:
# convert Series
my_series = pd.to_numeric(my_series)

# convert column "a" of a DataFrame
df["a"] = pd.to_numeric(df["a"])

SNIPPET:
>>> s = pd.Series(['1', '2', '4.7', 'pandas', '10'])
>>> s
0         1
1         2
2       4.7
3    pandas
4        10
dtype: object

###########
QUERY:pyplot subplots

GENERATED (& CHOSEN) SNIPPET:
fig.add_subplot(1, 1, 1)

SNIPPET:
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=4, ncols=4)
fig.tight_layout() # Or equivalently,  "plt.tight_layout()"

plt.show()

SNIPPET:
import random
import matplotlib.pyplot as plt

x = range(1, 101)
y1 = [random.randint(1, 100) for _ in xrange(len(x))]
y2 = [random.randint(1, 100) for _ in xrange(len(x))]

fig = plt.figure()
ax = fig.add_subplot(111)    # The big subplot
ax1 = fig.add_subplot(211)
ax2 = fig.add_subplot(212)

# Turn off axis lines and ticks of the big subplot
ax.spines['top'].set_color('none')
ax.spines['bottom'].set_color('none')
ax.spines['left'].set_color('none')
ax.spines['right'].set_color('none')
ax.tick_params(labelcolor='w', top=False, bottom=False, left=False, right=False)

ax1.loglog(x, y1)
ax2.loglog(x, y2)

# Set common labels
ax.set_xlabel('common xlabel')
ax.set_ylabel('common ylabel')

ax1.set_title('ax1 title')
ax2.set_title('ax2 title')

plt.savefig('common_labels.png', dpi=300)

SNIPPET:
f, axs = plt.subplots(2,2,figsize=(15,15))

SNIPPET:
subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=None)

SNIPPET:
left  = 0.125  # the left side of the subplots of the figure
right = 0.9    # the right side of the subplots of the figure
bottom = 0.1   # the bottom of the subplots of the figure
top = 0.9      # the top of the subplots of the figure
wspace = 0.2   # the amount of width reserved for blank space between subplots
hspace = 0.2   # the amount of height reserved for white space between subplots

SNIPPET:
import matplotlib.pyplot as plt
import numpy as np

fig=plt.figure()
data=np.arange(900).reshape((30,30))
for i in range(1,5):
    ax=fig.add_subplot(2,2,i)        
    ax.imshow(data)

fig.suptitle('Main title') # or plt.suptitle('Main title')
plt.show()

SNIPPET:
f.set_figheight(15)
f.set_figwidth(15)

CONALA MATCH:
fig.add_subplot(1, 1, 1)

CONALA EXACT MATCH:
fig.add_subplot(1, 1, 1)

###########
QUERY:random integer between 1 and 20

GENERATED (& CHOSEN) SNIPPET:
print(random.randint(0, 9))

SNIPPET:
return 1 if random.random() < 0.5 else -1

SNIPPET:
def NormalWORange(a, b, sigma):
    r = random.normalvariate(a,sigma)
    if r < a:
        return r-b
    else:
        return r+b

SNIPPET:
def RangeWORange(a, b, c, d):
    r = random.randrange(c,d-2*b) # 2*b because two intervals of length b to exclude
    if r >= a-b:
        return r+2*b
    else:
        return r

SNIPPET:
>>> import random
>>> random.uniform(-1, 1)
0.4779007751444888
>>> random.uniform(-1, 1)
-0.10028581710574902

SNIPPET:
Random number:    1  2  3  4  5  6  7  8
Result:           1  2  3  4  7  8  9 10

SNIPPET:
def rand(exclude):
    r = None
    while r in exclude or r is None:
         r = random.randrange(1,10)
    return r

rand([1,3,9])

SNIPPET:
import random
numbers = range(a,b) + range(c,d)
r = random.choice(numbers)

CONALA MATCH:
randint(0, 9)

###########
QUERY:trim heading whitespace

GENERATED (& CHOSEN) SNIPPET:
re.sub('\\s+', '', string)

SNIPPET:
sentence = ' hello  apple'
sentence.replace(" ", "")
>>> 'helloapple'

SNIPPET:
def strip_one_space(s):
    if s.endswith(" "): s = s[:-1]
    if s.startswith(" "): s = s[1:]
    return s

>>> strip_one_space("   Hello ")
'  Hello'

SNIPPET:
s = "  \t a string example\t  "
s = s.strip()

SNIPPET:
sentence = ' hello  apple'
sentence.strip()
>>> 'hello  apple'

SNIPPET:
>>> ' Hello '.strip()
'Hello'
>>> ' Hello'.strip()
'Hello'
>>> 'Bob has a cat'.strip()
'Bob has a cat'
>>> '   Hello   '.strip()  # ALL consecutive spaces at both ends removed
'Hello'

SNIPPET:
>>> "  Hello\n".strip(" ")
'Hello\n'

SNIPPET:
sentence = ' hello  apple'
" ".join(sentence.split())
>>> 'hello apple'

###########
QUERY:normalize newlines to \n

GENERATED (& CHOSEN) SNIPPET:
os.path.chr().encode('utf-8')

SNIPPET:
infile = open("filename", 'r')

SNIPPET:
First line
 Second line

SNIPPET:
infile = open("filename", 'rt')

SNIPPET:
infile = open("filename", 'rU')

SNIPPET:
mytext = "<br />".join(mytext.split("\n"))

SNIPPET:
infile = open("filename", 'rb')

SNIPPET:
print('First line \n Second line')

###########
QUERY:list of filenames from a folder

GENERATED (& CHOSEN) SNIPPET:
os.walk(filenames)

SNIPPET:
['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]

SNIPPET:
from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break

SNIPPET:
import os
 arr = os.listdir()
 print(arr)

 >>> ['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']

SNIPPET:
import glob
print(glob.glob("/home/adam/*.txt"))

SNIPPET:
from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]

SNIPPET:
import glob

mylist = [f for f in glob.glob("*.txt")]

SNIPPET:
import glob

txtfiles = []
for file in glob.glob("*.txt"):
    txtfiles.append(file)

###########
QUERY:generate random numbers

GENERATED (& CHOSEN) SNIPPET:
random.randint(0, 7)

SNIPPET:
import random
random.sample(range(100), 10)

SNIPPET:
>>> import random
>>> random.sample(range(1, 100), 3)
[77, 52, 45]

SNIPPET:
import random
random.uniform(0, 1)

SNIPPET:
from random import randint
randint(100, 999)  # randint is inclusive at both ends

SNIPPET:
>>> try:
...   random.sample(range(1, 2), 3)
... except ValueError:
...   print('Sample size exceeded population size.')
... 
Sample size exceeded population size

SNIPPET:
random.randint(a, b)

SNIPPET:
>>> import numpy as np, numpy.random
>>> print np.random.dirichlet(np.ones(10),size=1)
[[ 0.01779975  0.14165316  0.01029262  0.168136    0.03061161  0.09046587
   0.19987289  0.13398581  0.03119906  0.17598322]]

>>> print np.random.dirichlet(np.ones(10)/1000.,size=1)
[[  2.63435230e-115   4.31961290e-209   1.41369771e-212   1.42417285e-188
    0.00000000e+000   5.79841280e-143   0.00000000e+000   9.85329725e-005
    9.99901467e-001   8.37460207e-246]]

>>> print np.random.dirichlet(np.ones(10)*1000.,size=1)
[[ 0.09967689  0.10151585  0.10077575  0.09875282  0.09935606  0.10093678
   0.09517132  0.09891358  0.10206595  0.10283501]]

SNIPPET:
numpy.random.choice(numpy.arange(1, 7), p=[0.1, 0.05, 0.05, 0.2, 0.4, 0.2])

SNIPPET:
from random import randrange
print(randrange(10))

SNIPPET:
33
124
5127

SNIPPET:
import random
print(random.randint(0,9))

SNIPPET:
from random import randint

def random_with_N_digits(n):
    range_start = 10**(n-1)
    range_end = (10**n)-1
    return randint(range_start, range_end)

print random_with_N_digits(2)
print random_with_N_digits(3)
print random_with_N_digits(4)

###########
QUERY:get all files in directory

GENERATED (& CHOSEN) SNIPPET:
for dirname, dirnames, filenames in os.walk('<unk>'):
    for subdirname in dirnames:
        print(os.path.join(dirname, subdirname))
    for filename in filenames:
        pass

SNIPPET:
['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]

SNIPPET:
from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break

SNIPPET:
import glob
print(glob.glob("/home/adam/*.txt"))

SNIPPET:
from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]

SNIPPET:
import os
for root, dirs, files in os.walk("/mydir"):
    for file in files:
        if file.endswith(".txt"):
             print(os.path.join(root, file))

SNIPPET:
import glob, os
os.chdir("/mydir")
for file in glob.glob("*.txt"):
    print(file)

SNIPPET:
import os
for file in os.listdir("/mydir"):
    if file.endswith(".txt"):
        print(os.path.join("/mydir", file))

###########
QUERY:current time

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.now().time()

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

MATCH:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
Python 2.7.3 (default, Apr 24 2012, 00:00:54) 
[GCC 4.7.0 20120414 (prerelease)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import time
>>> ts = time.time()
>>> print ts
1355563265.81
>>> import datetime
>>> st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')
>>> print st
2012-12-15 01:21:05
>>>

SNIPPET:
import time

current_milli_time = lambda: int(round(time.time() * 1000))

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
import time
millis = int(round(time.time() * 1000))
print millis

CONALA MATCH:
datetime.datetime.now()

CONALA MATCH:
datetime.datetime.now().time()

CONALA EXACT MATCH:
datetime.datetime.now().time()

###########
QUERY:get curren time

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.now().time()

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

MATCH:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
>>> current_milli_time()
1378761833768

SNIPPET:
import time

current_milli_time = lambda: int(round(time.time() * 1000))

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
import time
millis = int(round(time.time() * 1000))
print millis

CONALA MATCH:
datetime.datetime.now()

CONALA MATCH:
datetime.datetime.now().time()

CONALA EXACT MATCH:
datetime.datetime.now().time()

###########
QUERY:get a random letter

GENERATED (& CHOSEN) SNIPPET:
s = random.choice('<unk>')

SNIPPET:
>>> import string
>>> import random
>>> def id_generator(size=6, chars=string.ascii_uppercase + string.digits):
...    return ''.join(random.choice(chars) for _ in range(size))
...
>>> id_generator()
'G5G74W'
>>> id_generator(3, "6793YUIO")
'Y3U'

SNIPPET:
''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(N))

SNIPPET:
import random

foo = ['a', 'b', 'c', 'd', 'e']
print(random.choice(foo))

SNIPPET:
import random

secure_random = random.SystemRandom()
print(secure_random.choice(foo))

SNIPPET:
''.join(random.choices(string.ascii_uppercase + string.digits, k=N))

SNIPPET:
''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))

SNIPPET:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))

###########
QUERY:random number

GENERATED (& CHOSEN) SNIPPET:
random.choice(random.randint(0, 10))

SNIPPET:
import random
random.sample(range(100), 10)

SNIPPET:
>>> random.uniform(1.5, 1.9)
1.8733202628557872

SNIPPET:
import random
random.uniform(0, 1)

SNIPPET:
random.randint(a, b)

SNIPPET:
all_lines = f1.readlines()
for i in range(50):
    lines = random.sample(all_lines, 40)

SNIPPET:
from random import randrange
print(randrange(10))

SNIPPET:
import random
print(random.randint(0,9))

###########
QUERY:pandas read csv

GENERATED (& CHOSEN) SNIPPET:
df = pd.read_csv('my.csv', na_values=['%H:%M:%S'])

SNIPPET:
import pandas as pd
import io
import requests
url="https://raw.githubusercontent.com/cs109/2014_data/master/countries.csv"
s=requests.get(url).content
c=pd.read_csv(io.StringIO(s.decode('utf-8')))

SNIPPET:
import pandas as pd

url="https://raw.githubusercontent.com/cs109/2014_data/master/countries.csv"
c=pd.read_csv(url)

SNIPPET:
encoding = "cp1252"
encoding = "ISO-8859-1"

SNIPPET:
import pandas as pd
data = pd.read_csv('file_name.csv', encoding='utf-8')

SNIPPET:
import pandas as pd
print pd.read_csv('value.txt')

        Date    price  factor_1  factor_2
0  2012-06-11  1600.20     1.255     1.548
1  2012-06-12  1610.02     1.258     1.554
2  2012-06-13  1618.07     1.249     1.552
3  2012-06-14  1624.40     1.253     1.556
4  2012-06-15  1626.15     1.258     1.552
5  2012-06-16  1626.15     1.263     1.558
6  2012-06-17  1626.15     1.264     1.572

SNIPPET:
import pandas as pd
df = pd.read_csv('file_name.csv', engine='python')

SNIPPET:
chunksize = 10 ** 6
for chunk in pd.read_csv(filename, chunksize=chunksize):
    process(chunk)

###########
QUERY:pandas read csv named "data.csv"

GENERATED (& CHOSEN) SNIPPET:
df = pd.read_csv('data.csv', sep='data.csv')

SNIPPET:
from numpy import genfromtxt
genfromtxt(fname = dest_file, dtype = (<whatever options>))

SNIPPET:
1.0, 2, 3
4, 5.5, 6

import numpy as np
np.genfromtxt('myfile.csv',delimiter=',')

SNIPPET:
array([(1.0, 2.0, 3), (4.0, 5.5, 6)], 
      dtype=[('f0', '<f8'), ('f1', '<f8'), ('f2', '<i4')])

SNIPPET:
array([[ 1. ,  2. ,  3. ],
       [ 4. ,  5.5,  6. ]])

SNIPPET:
import pandas as pd
df=pd.read_csv('myfile.csv', sep=',',header=None)
df.values
array([[ 1. ,  2. ,  3. ],
       [ 4. ,  5.5,  6. ]])

SNIPPET:
from numpy import genfromtxt
my_data = genfromtxt('my_file.csv', delimiter=',')

SNIPPET:
np.genfromtxt('myfile.csv',delimiter=',',dtype=None)

###########
QUERY:save this dataframe to a csv

GENERATED (& CHOSEN) SNIPPET:
df.to_csv('skiprows', index=False)

SNIPPET:
Color,Number
red,22
blue,10

SNIPPET:
df.to_csv(file_name, sep='\t', encoding='utf-8')

SNIPPET:
,Color,Number
0,red,22
1,blue,10

SNIPPET:
Color  Number
0   red     22
1  blue     10

SNIPPET:
df.to_csv(file_name, sep='\t')

SNIPPET:
header = True
for chunk in chunks:

    chunk.to_csv(os.path.join(folder, new_folder, "new_file_" + filename),
        header=header, cols=[['TIME','STUFF']], mode='a')

    header = False

SNIPPET:
df.to_csv(file_name, encoding='utf-8', index=False)

###########
QUERY:read a json file named `f`

GENERATED (& CHOSEN) SNIPPET:
data = json.loads(f)

SNIPPET:
import json
data = json.loads('{"one" : "1", "two" : "2", "three" : "3"}')
print data['two']

SNIPPET:
j = urllib2.urlopen('http://site.com/data.json')

SNIPPET:
import json

with open("test.json") as json_file:
    json_data = json.load(json_file)
    print(json_data)

SNIPPET:
{
    "a": [1,3,"asdf",true],
    "b": {
        "Hello": "world"
    }
}

SNIPPET:
import json

with open('strings.json') as f:
    d = json.load(f)
    print(d)

SNIPPET:
import json

with open('data.json', 'r+') as f:
    data = json.load(f)
    data['id'] = 134 # <--- add `id` value.
    f.seek(0)        # <--- should reset file position to the beginning.
    json.dump(data, f, indent=4)
    f.truncate()     # remove remaining part

SNIPPET:
j_obj = json.load(j)

###########
QUERY:numpy load from csv

GENERATED (& CHOSEN) SNIPPET:
np.genfromtxt('<unk>', delimiter=',')

SNIPPET:
1.0, 2, 3
4, 5.5, 6

import numpy as np
np.genfromtxt('myfile.csv',delimiter=',')

SNIPPET:
array([(1.0, 2.0, 3), (4.0, 5.5, 6)], 
      dtype=[('f0', '<f8'), ('f1', '<f8'), ('f2', '<i4')])

SNIPPET:
array([[ 1. ,  2. ,  3. ],
       [ 4. ,  5.5,  6. ]])

SNIPPET:
import pandas as pd
df=pd.read_csv('myfile.csv', sep=',',header=None)
df.values
array([[ 1. ,  2. ,  3. ],
       [ 4. ,  5.5,  6. ]])

SNIPPET:
numpy.loadtxt(open("test.csv", "rb"), delimiter=",", skiprows=1)

SNIPPET:
from numpy import genfromtxt
my_data = genfromtxt('my_file.csv', delimiter=',')

SNIPPET:
np.genfromtxt('myfile.csv',delimiter=',',dtype=None)

###########
QUERY:open file

GENERATED (& CHOSEN) SNIPPET:
with open(file) as f:
    f = f.readlines()

SNIPPET:
>>> f = open('/tmp/generic.png','r')
>>> f.name
'/tmp/generic.png'
>>> import os
>>> os.path.basename(f.name)
'generic.png'

SNIPPET:
import glob
for filename in glob.glob('*.txt'):
   with open(os.path.join(os.cwd(), filename), 'r') as f: # open in readonly mode
      # do your stuff

SNIPPET:
$ ls -la chardet-1.0.1.tgz
-rwxr-xr-x 1 vinko vinko 179218 2008-10-20 17:49 chardet-1.0.1.tgz
$ python
Python 2.5.1 (r251:54863, Jul 31 2008, 22:53:39)
[GCC 4.1.2 (Ubuntu 4.1.2-0ubuntu4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> f = open('chardet-1.0.1.tgz','rb')
>>> f.seek(0,2)
>>> f.tell()
179218L

SNIPPET:
import fileinput
for line in fileinput.input():
    # do your stuff

SNIPPET:
def filter(txt, oldfile, newfile):
    '''\
    Read a list of names from a file line by line into an output file.
    If a line begins with a particular name, insert a string of text
    after the name before appending the line to the output file.
    '''

    with open(newfile, 'w') as outfile, open(oldfile, 'r', encoding='utf-8') as infile:
        for line in infile:
            if line.startswith(txt):
                line = line[0:len(txt)] + ' - Truly a great person!\n'
            outfile.write(line)

# input the name you want to check against
text = input('Please enter the name of a great person: ')    
letsgo = filter(text,'Spanish', 'Spanish2')

SNIPPET:
with open('filename') as f:
    lines = [line.rstrip() for line in f]

SNIPPET:
with open("file.txt") as file_in:
    lines = []
    for line in file_in:
        lines.append(line)

SNIPPET:
import os
for filename in os.listdir(os.getcwd()):
   with open(os.path.join(os.cwd(), filename), 'r') as f: # open in readonly mode
      # do your stuff

SNIPPET:
ls -1 | python parse.py

SNIPPET:
with open(filename) as f:
    content = f.readlines()
# you may also want to remove whitespace characters like `\n` at the end of each line
content = [x.strip() for x in content]

SNIPPET:
with open('filename') as f:
    lines = f.readlines()

SNIPPET:
import subprocess, os, platform
if platform.system() == 'Darwin':       # macOS
    subprocess.call(('open', filepath))
elif platform.system() == 'Windows':    # Windows
    os.startfile(filepath)
else:                                   # linux variants
    subprocess.call(('xdg-open', filepath))

SNIPPET:
path = '/some/path/to/file'
for filename in glob.glob(os.path.join(path, '*.txt')):
   with open(os.path.join(os.cwd(), filename), 'r') as f: # open in readonly mode
      # do your stuff

###########
QUERY:plot bar

GENERATED (& CHOSEN) SNIPPET:
bar.plot(kind='bar')

SNIPPET:
import matplotlib.pyplot as plt

D = {u'Label1':26, u'Label2': 17, u'Label3':30}

plt.bar(range(len(D)), list(D.values()), align='center')
plt.xticks(range(len(D)), list(D.keys()))
# # for python 2.x:
# plt.bar(range(len(D)), D.values(), align='center')  # python 2.x
# plt.xticks(range(len(D)), D.keys())  # in python 2.x

plt.show()

SNIPPET:
weekdays = ['Mon', 'Tues', 'Weds', 'Thurs', 'Fri', 'Sat', 'Sun']
mapping = {day: i for i, day in enumerate(weekdays)}
key = df['day'].map(mapping)

SNIPPET:
ax = plt.subplot(111)
w = 0.3
ax.bar(x-w, y, width=w, color='b', align='center')
ax.bar(x, z, width=w, color='g', align='center')
ax.bar(x+w, k, width=w, color='r', align='center')
ax.xaxis_date()
ax.autoscale(tight=True)

plt.show()

SNIPPET:
import matplotlib.pyplot as plt

D = {u'Label1':26, u'Label2': 17, u'Label3':30}

plt.bar(range(len(D)), D.values(), align='center')
plt.xticks(range(len(D)), list(D.keys()))

plt.show()

SNIPPET:
import matplotlib.pyplot as plt

D = {u'Label1':26, u'Label2': 17, u'Label3':30}
plt.bar(*zip(*D.items()))
plt.show()

SNIPPET:
import numpy as np
import matplotlib.pyplot as plt

N = 3
ind = np.arange(N)  # the x locations for the groups
width = 0.27       # the width of the bars

fig = plt.figure()
ax = fig.add_subplot(111)

yvals = [4, 9, 2]
rects1 = ax.bar(ind, yvals, width, color='r')
zvals = [1,2,3]
rects2 = ax.bar(ind+width, zvals, width, color='g')
kvals = [11,12,13]
rects3 = ax.bar(ind+width*2, kvals, width, color='b')

ax.set_ylabel('Scores')
ax.set_xticks(ind+width)
ax.set_xticklabels( ('2011-Jan-4', '2011-Jan-5', '2011-Jan-6') )
ax.legend( (rects1[0], rects2[0], rects3[0]), ('y', 'z', 'k') )

def autolabel(rects):
    for rect in rects:
        h = rect.get_height()
        ax.text(rect.get_x()+rect.get_width()/2., 1.05*h, '%d'%int(h),
                ha='center', va='bottom')

autolabel(rects1)
autolabel(rects2)
autolabel(rects3)

plt.show()

SNIPPET:
import matplotlib.pyplot as plt
from matplotlib.dates import date2num
import datetime

x = [
    datetime.datetime(2011, 1, 4, 0, 0),
    datetime.datetime(2011, 1, 5, 0, 0),
    datetime.datetime(2011, 1, 6, 0, 0)
]
x = date2num(x)

y = [4, 9, 2]
z = [1, 2, 3]
k = [11, 12, 13]

ax = plt.subplot(111)
ax.bar(x-0.2, y, width=0.2, color='b', align='center')
ax.bar(x, z, width=0.2, color='g', align='center')
ax.bar(x+0.2, k, width=0.2, color='r', align='center')
ax.xaxis_date()

plt.show()

###########
QUERY:generate random between 0 and 20

GENERATED (& CHOSEN) SNIPPET:
random.randint(0, 9)[0]

SNIPPET:
import random
random.uniform(0, 1)

SNIPPET:
>>> import random
>>> for i in range(10):
...     print(random.random())
... 
0.908047338626
0.0199900075962
0.904058545833
0.321508119045
0.657086320195
0.714084413092
0.315924955063
0.696965958019
0.93824013683
0.484207425759

SNIPPET:
df = pd.DataFrame(np.random.randint(0,100,size=(100, 4)), columns=list('ABCD'))

SNIPPET:
A   B   C   D
0   45  88  44  92
1   62  34   2  86
2   85  65  11  31
3   74  43  42  56
4   90  38  34  93
5    0  94  45  10
6   58  23  23  60
..  ..  ..  ..  ..

SNIPPET:
import numpy as np
import pandas as pd
df = pd.DataFrame(np.random.randint(0,100,size=(100, 4)), columns=list('ABCD'))

SNIPPET:
nums = numpy.ones(1000)
nums[:100] = 0
numpy.random.shuffle(nums)

SNIPPET:
>>> import os
>>> int.from_bytes(os.urandom(8), byteorder="big") / ((1 << 64) - 1)
0.7409674234050893

CONALA MATCH:
randint(0, 9)

###########
QUERY:find character

GENERATED (& CHOSEN) SNIPPET:
re.findall('<unk>', character)

SNIPPET:
>>> ord('a')
97
>>> chr(97)
'a'
>>> chr(ord('a') + 3)
'd'
>>>

SNIPPET:
>>> myString = 'Position of a character'
>>> myString.index('s')
2
>>> myString.index('x')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: substring not found

SNIPPET:
pattern = re.compile(r'\d\$,')
if pattern.findall(s):
    print('Found')
else
    print('Not found')

SNIPPET:
'$' in s        # found
'$' not in s    # not found

# original answer given, but less Pythonic than the above...
s.find('$')==-1 # not found
s.find('$')!=-1 # found

SNIPPET:
>>> unichr(97)
u'a'
>>> unichr(1234)
u'\u04d2'

SNIPPET:
chars = set('0123456789$,')
if any((c in chars) for c in s):
    print('Found')
else:
    print('Not Found')

SNIPPET:
>>> myString = 'Position of a character'
>>> myString.find('s')
2
>>> myString.find('x')
-1

###########
QUERY:travverse list of files

GENERATED (& CHOSEN) SNIPPET:
shutil.from_iterable(my_list)

SNIPPET:
['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]

SNIPPET:
from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break

SNIPPET:
import os
 arr = os.listdir()
 print(arr)

 >>> ['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']

SNIPPET:
import glob
print(glob.glob("/home/adam/*.txt"))

SNIPPET:
from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]

SNIPPET:
import glob

mylist = [f for f in glob.glob("*.txt")]

SNIPPET:
import glob

txtfiles = []
for file in glob.glob("*.txt"):
    txtfiles.append(file)

###########
QUERY:convert str to utf-8

GENERATED (& CHOSEN) SNIPPET:
"""""".join(str(c) for c in 'AndrÃ©').decode('utf8')

SNIPPET:
In [1]: %timeit -r 10 'abc'.encode('utf-8')
The slowest run took 38.07 times longer than the fastest. 
This could mean that an intermediate result is being cached.
10000000 loops, best of 10: 183 ns per loop

In [2]: %timeit -r 10 'abc'.encode()
The slowest run took 27.34 times longer than the fastest. 
This could mean that an intermediate result is being cached.
10000000 loops, best of 10: 137 ns per loop

SNIPPET:
my_str = "hello world"
my_str_as_bytes = str.encode(my_str)
type(my_str_as_bytes) # ensure it is byte representation
my_decoded_str = my_str_as_bytes.decode()
type(my_decoded_str) # ensure it is string representation

SNIPPET:
>>> s = "Hello!"
>>> u = unicode(s, "utf-8")

SNIPPET:
>>> plain_string = "Hi!"
>>> unicode_string = u"Hi!"
>>> type(plain_string), type(unicode_string)
(<type 'str'>, <type 'unicode'>)

SNIPPET:
>>> a=u"aaaàçççñññ"
>>> type(a)
<type 'unicode'>
>>> a.encode('ascii','ignore')
'aaa'
>>> a.encode('ascii','replace')
'aaa???????'
>>>

SNIPPET:
title = u"Klüft skräms inför på fédéral électoral große"
import unicodedata
unicodedata.normalize('NFKD', title).encode('ascii', 'ignore')
'Kluft skrams infor pa federal electoral groe'

SNIPPET:
b = mystring.encode()

###########
QUERY:load json file

GENERATED (& CHOSEN) SNIPPET:
json.loads(file)

SNIPPET:
import simplejson as json
import ordereddict

my_ordered_dict = json.loads(json_str, object_pairs_hook=ordereddict.OrderedDict)

SNIPPET:
my_ordered_dict = json.loads(json_str, object_pairs_hook=collections.OrderedDict)

SNIPPET:
>>> data = json.load(open('config.json'), object_pairs_hook=OrderedDict)

SNIPPET:
import json

data = []
with open('file') as f:
    for line in f:
        data.append(json.loads(line))

SNIPPET:
import json

with open('strings.json') as f:
    d = json.load(f)
    print(d)

SNIPPET:
>>> json.JSONDecoder(object_pairs_hook=collections.OrderedDict).decode('{"foo":1, "bar": 2}')
OrderedDict([('foo', 1), ('bar', 2)])
>>>

SNIPPET:
>>> import json
>>> from collections import OrderedDict
>>> data = json.loads('{"foo":1, "bar": 2}', object_pairs_hook=OrderedDict)
>>> print json.dumps(data, indent=4)
{
    "foo": 1,
    "bar": 2
}
>>>

###########
QUERY:add json file to a list

GENERATED (& CHOSEN) SNIPPET:
data = json.loads(data)

SNIPPET:
import io, json
with io.open('data.txt', 'w', encoding='utf-8') as f:
  f.write(json.dumps(data, ensure_ascii=False))

SNIPPET:
import json, codecs
with open('data.txt', 'wb') as f:
    json.dump(data, codecs.getwriter('utf-8')(f), ensure_ascii=False)

SNIPPET:
import json
with open('data.json', 'w', encoding='utf-8') as f:
    json.dump(data, f, ensure_ascii=False, indent=4)

SNIPPET:
import json
with open('data.txt', 'w') as f:
  json.dump(data, f, ensure_ascii=False)

SNIPPET:
with open('data.txt', 'w') as outfile:
     json.dump(jsonData, outfile, sort_keys = True, indent = 4,
               ensure_ascii = False)

SNIPPET:
>>> json.dumps({'price': '€10'})
'{"price": "\\u20ac10"}'
>>> json.dumps({'price': '€10'}, ensure_ascii=False)
'{"price": "€10"}'

>>> len(json.dumps({'абвгд': 1}))
37
>>> len(json.dumps({'абвгд': 1}, ensure_ascii=False).encode('utf8'))
17

SNIPPET:
import json
with open('data.json', 'w') as f:
    json.dump(data, f)

###########
QUERY:loop over a range of `count`

GENERATED (& CHOSEN) SNIPPET:
for x in range(0, 10):
    pass

SNIPPET:
import pandas as pd
daterange = pd.date_range(start_date, end_date)

SNIPPET:
from datetime import timedelta, date

def daterange(start_date, end_date):
    for n in range(int((end_date - start_date).days)):
        yield start_date + timedelta(n)

start_date = date(2013, 1, 1)
end_date = date(2015, 6, 2)
for single_date in daterange(start_date, end_date):
    print(single_date.strftime("%Y-%m-%d"))

SNIPPET:
for single_date in (start_date + timedelta(n) for n in range(day_count)):
    print ...

SNIPPET:
from datetime import date, timedelta

start_date = date(2019, 1, 1)
end_date = date(2020, 1, 1)
delta = timedelta(days=1)
while start_date <= end_date:
    print (start_date.strftime("%Y-%m-%d"))
    start_date += delta

SNIPPET:
for idx,item in enumerate(list):

SNIPPET:
#count=0
for idx, item in enumerate(list):
    print item
    #count +=1
    #if count % 10 == 0:
    if (idx+1) % 10 == 0:
        print 'did ten'

SNIPPET:
from datetime import date
from dateutil.rrule import rrule, DAILY

a = date(2009, 5, 30)
b = date(2009, 6, 9)

for dt in rrule(DAILY, dtstart=a, until=b):
    print dt.strftime("%Y-%m-%d")

###########
QUERY:randomly pick an item from `seq`

GENERATED (& CHOSEN) SNIPPET:
random.choice(random.choice(seq.random))

SNIPPET:
import random
d = {'VENEZUELA':'CARACAS', 'CANADA':'OTTAWA'}
random.choice(list(d.values()))

SNIPPET:
country, capital = random.choice(list(d.items()))

SNIPPET:
import random

foo = ['a', 'b', 'c', 'd', 'e']
print(random.choice(foo))

SNIPPET:
import random

secure_random = random.SystemRandom()
print(secure_random.choice(foo))

SNIPPET:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))

SNIPPET:
from numpy.random import choice
draw = choice(list_of_candidates, number_of_items_to_pick,
              p=probability_distribution)

SNIPPET:
Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04)
Type 'copyright', 'credits' or 'license' for more information
IPython 6.0.0 -- An enhanced Interactive Python. Type '?' for help.

In [1]: import random

In [2]: random.choices(
...:     population=[['a','b'], ['b','a'], ['c','b']],
...:     weights=[0.2, 0.2, 0.6],
...:     k=10
...: )

Out[2]:
[['c', 'b'],
 ['c', 'b'],
 ['b', 'a'],
 ['c', 'b'],
 ['c', 'b'],
 ['b', 'a'],
 ['c', 'b'],
 ['b', 'a'],
 ['c', 'b'],
 ['c', 'b']]

###########
QUERY:call `pick_with_replacement`

GENERATED (& CHOSEN) SNIPPET:
pick_with_replacement()

SNIPPET:
def clear_a(x):
  x = []

def clear_b(x):
  while x: x.pop()

z = [1,2,3]
clear_a(z) # z will not be changed
clear_b(z) # z will be emptied

SNIPPET:
def append_one(li):
    li = [0, 1]
x = [0]
append_one(x)
print x

SNIPPET:
def foo(y):
  y[0] = y[0]**2

x = [5]
foo(x)
print x[0]  # prints 25

SNIPPET:
np.random.choice(
  ['pooh', 'rabbit', 'piglet', 'Christopher'], 
  5,
  p=[0.5, 0.1, 0.1, 0.3]
)

SNIPPET:
>>> x = []

SNIPPET:
def append_one(li):
    li.append(1)
x = [0]
append_one(x)
print x

SNIPPET:
def foo(x, y):
   return x**2, y**2

a = 2
b = 3
a, b = foo(a, b)  # a == 4; b == 9

###########
QUERY:zip `hundred_characters` with `hundred_numbers`

GENERATED (& CHOSEN) SNIPPET:
[(x + y) for x, y in zip(hundred_characters, hundred_numbers)]

SNIPPET:
>>> np.array(list(zip(a.ravel(),b.ravel())), dtype=('i4,i4')).reshape(a.shape)
array([[(0, 0), (1, 1), (2, 2), (3, 3)],
       [(4, 4), (5, 5), (6, 6), (7, 7)]],
      dtype=[('f0', '<i4'), ('f1', '<i4')])

SNIPPET:
A = [1,2,3,4,5,6,7,8,9]
B = ["A","B","C"]

from itertools import cycle
zip_list = zip(A, cycle(B)) if len(A) > len(B) else zip(cycle(A), B)

SNIPPET:
list(zip(a,b,zip(c[0::2],c[1::2]),d))

SNIPPET:
import numpy as np

a = np.array([1,2,3,4,5])
b = np.array([6,7,8,9,10])

c = np.dstack((a,b))
#or
d = np.column_stack((a,b))

>>> c
array([[[ 1,  6],
        [ 2,  7],
        [ 3,  8],
        [ 4,  9],
        [ 5, 10]]])
>>> d
array([[ 1,  6],
       [ 2,  7],
       [ 3,  8],
       [ 4,  9],
       [ 5, 10]])

>>> c.shape
(1, 5, 2)
>>> d.shape
(5, 2)

SNIPPET:
>>> np.array(zip(a.ravel(),b.ravel()), dtype=('i4,i4')).reshape(a.shape)
array([[(0, 0), (1, 1), (2, 2), (3, 3)],
       [(4, 4), (5, 5), (6, 6), (7, 7)]],
      dtype=[('f0', '<i4'), ('f1', '<i4')])

SNIPPET:
np.array(list(zip(a,b)))

SNIPPET:
>>> np.dstack((a,b))
array([[[0, 0],
        [1, 1],
        [2, 2],
        [3, 3]],

       [[4, 4],
        [5, 5],
        [6, 6],
        [7, 7]]])

###########
QUERY:list all text files in the data directory

GENERATED (& CHOSEN) SNIPPET:
for dirname, dirnames, filenames in os.walk('<unk>'):
    for line in f:
        e = f.read()
    for line in os.listdir('<unk>'):
        e = f.read()
    for line in filenames:
        pass

SNIPPET:
['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]

SNIPPET:
from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break

SNIPPET:
import glob
print(glob.glob("/home/adam/*.txt"))

SNIPPET:
from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]

SNIPPET:
import os
for root, dirs, files in os.walk("/mydir"):
    for file in files:
        if file.endswith(".txt"):
             print(os.path.join(root, file))

SNIPPET:
import glob, os
os.chdir("/mydir")
for file in glob.glob("*.txt"):
    print(file)

SNIPPET:
import os
for file in os.listdir("/mydir"):
    if file.endswith(".txt"):
        print(os.path.join("/mydir", file))

###########
QUERY:walke all files in a directory

GENERATED (& CHOSEN) SNIPPET:
os.listdir('..')

SNIPPET:
['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]

SNIPPET:
from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break

SNIPPET:
import os
 arr = os.listdir()
 print(arr)

 >>> ['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']

SNIPPET:
import glob
print(glob.glob("/home/adam/*.txt"))

SNIPPET:
from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]

SNIPPET:
import glob

mylist = [f for f in glob.glob("*.txt")]

SNIPPET:
import glob

txtfiles = []
for file in glob.glob("*.txt"):
    txtfiles.append(file)

###########
QUERY:list all filepaths in a directory

GENERATED (& CHOSEN) SNIPPET:
glob.glob('*')

SNIPPET:
['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]

SNIPPET:
from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break

SNIPPET:
import glob
print(glob.glob("/home/adam/*.txt"))

SNIPPET:
from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]

SNIPPET:
import os
for root, dirs, files in os.walk("/mydir"):
    for file in files:
        if file.endswith(".txt"):
             print(os.path.join(root, file))

SNIPPET:
import glob, os
os.chdir("/mydir")
for file in glob.glob("*.txt"):
    print(file)

SNIPPET:
import os
for file in os.listdir("/mydir"):
    if file.endswith(".txt"):
        print(os.path.join("/mydir", file))

CONALA MATCH:
glob.glob('*')

CONALA EXACT MATCH:
glob.glob('*')

###########
QUERY:search all matches in a string

GENERATED (& CHOSEN) SNIPPET:
re.findall('<unk>', s)

SNIPPET:
>>> help(str.find)
Help on method_descriptor:

find(...)
    S.find(sub [,start [,end]]) -> int

SNIPPET:
def find_all(a_str, sub):
    start = 0
    while True:
        start = a_str.find(sub, start)
        if start == -1: return
        yield start
        start += len(sub) # use start += 1 to find overlapping matches

list(find_all('spam spam spam spam', 'spam')) # [0, 5, 10, 15]

SNIPPET:
[(m.start(0), m.end(0)) for m in re.finditer(pattern, string)]

SNIPPET:
[m.start() for m in re.finditer('(?=tt)', 'ttt')]
#[0, 1]

SNIPPET:
import re
[m.start() for m in re.finditer('test', 'test test test test')]
#[0, 5, 10, 15]

SNIPPET:
>>> p = re.compile("name (.*) is valid")
>>> result = p.search(s)
>>> result
<_sre.SRE_Match object at 0x10555e738>
>>> result.group(1)     # group(1) will return the 1st capture.
                        # group(0) will returned the entire matched text.
'my_user_name'

SNIPPET:
search = 'tt'
[m.start() for m in re.finditer('(?=%s)(?!.{1,%d}%s)' % (search, len(search)-1, search), 'ttt')]
#[1]

SNIPPET:
re.findall( r'all (.*?) are', 'all cats are smarter than dogs, all dogs are dumber than cats')
# Output: ['cats', 'dogs']

[x.group() for x in re.finditer( r'all (.*?) are', 'all cats are smarter than dogs, all dogs are dumber than cats')]
# Output: ['all cats are', 'all dogs are']

SNIPPET:
re.finditer(pattern, string[, flags])

SNIPPET:
if any(ext in url_string for ext in extensionsToCheck):
    print(url_string)

###########
QUERY:move file

GENERATED (& CHOSEN) SNIPPET:
shutil.copy2(file, 'filenames')

SNIPPET:
>>> import shutil
>>> shutil.move(destination, source)
>>> os.listdir('/opt/awesome/source')
['awesome.txt']

SNIPPET:
in /opt/awesome
○ → ls
source
○ → ls source
awesome.txt

python 
>>> source = '/opt/awesome/source'
>>> destination = '/opt/awesome/destination'
>>> import os
>>> os.rename(source, destination)
>>> os.listdir('/opt/awesome')
['destination']

SNIPPET:
import boto

c = boto.connect_s3()
src = c.get_bucket('my_source_bucket')
dst = c.get_bucket('my_destination_bucket')

SNIPPET:
import os
import shutil

os.rename("path/to/current/file.foo", "path/to/new/destination/for/file.foo")
shutil.move("path/to/current/file.foo", "path/to/new/destination/for/file.foo")
os.replace("path/to/current/file.foo", "path/to/new/destination/for/file.foo")

SNIPPET:
from pathlib import Path

Path("path/to/current/file.foo").rename("path/to/new/destination/for/file.foo")

SNIPPET:
import shutil
import os

source = '/path/to/source_folder'
dest1 = '/path/to/dest_folder'

files = os.listdir(source)

for f in files:
    shutil.move(source+f, dest1)

SNIPPET:
for k in src.list():
    # copy stuff to your destination here
    dst.copy_key(k.key.name, src.name, k.key.name)
    # then delete the source key
    k.delete()

###########
QUERY:assign current date and time to `now`

GENERATED (& CHOSEN) SNIPPET:
now = datetime.now()

SNIPPET:
from datetime import datetime

datetime.today().strftime('%Y-%m-%d')

SNIPPET:
from datetime import datetime
datetime.now().strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
from datetime import date
from datetime import datetime

dt = datetime.combine(date.today(), datetime.min.time())

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

###########
QUERY:add days to time

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.now() + datetime.timedelta(days=1)

SNIPPET:
>>> '{:%H:%M:%S}'.format(nine_hours_from_now)
'23:24:31'

SNIPPET:
from datetime import datetime, timedelta

nine_hours_from_now = datetime.now() + timedelta(hours=9)
#datetime.datetime(2012, 12, 3, 23, 24, 31, 774118)

SNIPPET:
date_1 = datetime.datetime.strptime(start_date, "%m/%d/%y")

end_date = date_1 + datetime.timedelta(days=10)

SNIPPET:
import datetime

SNIPPET:
>>> format(nine_hours_from_now, '%H:%M:%S')
'23:24:31'

SNIPPET:
from datetime import timedelta, date

SNIPPET:
date = datetime.datetime(2003,8,1,12,4,5)
for i in range(5): 
    date += datetime.timedelta(days=1)
    print(date)

CONALA MATCH:
datetime.datetime.now()

###########
QUERY:convert `week_date` to GMT timezone and assign to `GMT_week_date`

GENERATED (& CHOSEN) SNIPPET:
GMT_week_date = datetime.datetime.strptime(week_date, 'GMT_week_date')

SNIPPET:
datetime.datetime.now().date()

SNIPPET:
In [4]: t = pd.date_range(start="2013-05-18 12:00:00", periods=2, freq='H',
                          tz= "Europe/Brussels")

In [5]: t
Out[5]: DatetimeIndex(['2013-05-18 12:00:00+02:00', '2013-05-18 13:00:00+02:00'],
                       dtype='datetime64[ns, Europe/Brussels]', freq='H')

SNIPPET:
In [6]: t.tz_localize(None)
Out[6]: DatetimeIndex(['2013-05-18 12:00:00', '2013-05-18 13:00:00'], 
                      dtype='datetime64[ns]', freq='H')

SNIPPET:
In [7]: t.tz_convert(None)
Out[7]: DatetimeIndex(['2013-05-18 10:00:00', '2013-05-18 11:00:00'], 
                      dtype='datetime64[ns]', freq='H')

SNIPPET:
>>> import datetime
>>> datetime.date(2010, 6, 16).isocalendar()[1]
24

SNIPPET:
>>> import datetime
>>> datetime.date(2010, 6, 16).strftime("%V")
'24'

SNIPPET:
from datetime import datetime
from dateutil import tz

# METHOD 1: Hardcode zones:
from_zone = tz.gettz('UTC')
to_zone = tz.gettz('America/New_York')

# METHOD 2: Auto-detect zones:
from_zone = tz.tzutc()
to_zone = tz.tzlocal()

# utc = datetime.utcnow()
utc = datetime.strptime('2011-01-21 02:37:21', '%Y-%m-%d %H:%M:%S')

# Tell the datetime object that it's in UTC time zone since 
# datetime objects are 'naive' by default
utc = utc.replace(tzinfo=from_zone)

# Convert time zone
central = utc.astimezone(to_zone)

###########
QUERY:display `week_date` in format mm-dd-yyyy hh:mm

GENERATED (& CHOSEN) SNIPPET:
time.strftime('%Y-%m-%d %H:%M:%S', gmtime())

SNIPPET:
from datetime import datetime

datetime.today().strftime('%Y-%m-%d')

SNIPPET:
>>> from datetime import datetime
>>> inDate = "29-Apr-2013-15:59:02"
>>> d = datetime.strptime(inDate, "%d-%b-%Y-%H:%M:%S")
>>> d
datetime.datetime(2013, 4, 29, 15, 59, 2)
>>> d.strftime("YYYYMMDD HH:mm:ss (%Y%m%d %H:%M:%S)")
'YYYYMMDD HH:mm:ss (20130429 15:59:02)'

SNIPPET:
>>> import arrow
>>> arrow.now().format('YYYY-MM-DD')
'2017-02-17'

SNIPPET:
datetime.today().strftime('%Y-%m-%d-%H:%M:%S')

SNIPPET:
from datetime import date
today = str(date.today())
print(today)   # '2017-12-26'

SNIPPET:
time.strftime('%m/%d/%Y', time.gmtime(os.path.getmtime(file)))

SNIPPET:
import datetime

datetime.datetime.strptime("21/12/2008", "%d/%m/%Y").strftime("%Y-%m-%d")

CONALA MATCH:
strftime('%Y-%m-%d %H:%M:%S', gmtime())

###########
QUERY:change datetime format of `week_date` to mm-dd-yyyy hh:mm

GENERATED (& CHOSEN) SNIPPET:
week_date.strftime('%Y-%m-%d %H:%M')

SNIPPET:
from datetime import datetime

datetime.today().strftime('%Y-%m-%d')

SNIPPET:
dt = datetime.datetime.strptime("2013-1-25", '%Y-%m-%d')
print '{0}/{1}/{2:02}'.format(dt.month, dt.day, dt.year % 100)

SNIPPET:
datetime.datetime.strptime("2013-1-25", '%Y-%m-%d').strftime('%m/%d/%y')

SNIPPET:
datetime.today().strftime('%Y-%m-%d-%H:%M:%S')

SNIPPET:
from datetime import date
today = str(date.today())
print(today)   # '2017-12-26'

SNIPPET:
import datetime

datetime.datetime.strptime("21/12/2008", "%d/%m/%Y").strftime("%Y-%m-%d")

###########
QUERY:read csv file "data.csv"

GENERATED (& CHOSEN) SNIPPET:
df = pd.read_csv('data.csv', sep=',', header=None)

SNIPPET:
from numpy import genfromtxt
genfromtxt(fname = dest_file, dtype = (<whatever options>))

SNIPPET:
1.0, 2, 3
4, 5.5, 6

import numpy as np
np.genfromtxt('myfile.csv',delimiter=',')

SNIPPET:
Data = namedtuple("Data", next(reader))

SNIPPET:
import timeit
import csv
import pandas as pd

filename = './sample_submission.csv'

def talktime(filename, funcname, func):
    print(f"# {funcname}")
    t = timeit.timeit(f'{funcname}("{filename}")', setup=f'from __main__ import {funcname}', number = 100) / 100
    print('Elapsed time : ', t)
    print('n = ', func(filename))
    print('\n')

def sum1forline(filename):
    with open(filename) as f:
        return sum(1 for line in f)
talktime(filename, 'sum1forline', sum1forline)

def lenopenreadlines(filename):
    with open(filename) as f:
        return len(f.readlines())
talktime(filename, 'lenopenreadlines', lenopenreadlines)

def lenpd(filename):
    return len(pd.read_csv(filename)) + 1
talktime(filename, 'lenpd', lenpd)

def csvreaderfor(filename):
    cnt = 0
    with open(filename) as f:
        cr = csv.reader(f)
        for row in cr:
            cnt += 1
    return cnt
talktime(filename, 'csvreaderfor', csvreaderfor)

def openenum(filename):
    cnt = 0
    with open(filename) as f:
        for i, line in enumerate(f,1):
            cnt += 1
    return cnt
talktime(filename, 'openenum', openenum)

SNIPPET:
with open(filename) as f:
    sum(1 for line in f)

SNIPPET:
row_count = sum(1 for row in fileObject)  # fileObject is your csv.reader

SNIPPET:
next(reader)

SNIPPET:
array([(1.0, 2.0, 3), (4.0, 5.5, 6)], 
      dtype=[('f0', '<f8'), ('f1', '<f8'), ('f2', '<i4')])

SNIPPET:
import csv
from collections import namedtuple
from itertools import imap

with open("data_file.txt", mode="rb") as infile:
    reader = csv.reader(infile)
    Data = namedtuple("Data", next(reader))  # get names from column headers
    for data in imap(Data._make, reader):
        print data.foo
        # ...further processing of a line...

SNIPPET:
array([[ 1. ,  2. ,  3. ],
       [ 4. ,  5.5,  6. ]])

SNIPPET:
import pandas as pd
df=pd.read_csv('myfile.csv', sep=',',header=None)
df.values
array([[ 1. ,  2. ,  3. ],
       [ 4. ,  5.5,  6. ]])

SNIPPET:
# sum1forline
Elapsed time :  0.6327946722068599
n =  2528244


# lenopenreadlines
Elapsed time :  0.655304473598555
n =  2528244


# lenpd
Elapsed time :  0.7561274056295324
n =  2528244


# csvreaderfor
Elapsed time :  1.5571560935772661
n =  2528244


# openenum
Elapsed time :  0.773000013928679
n =  2528244

SNIPPET:
from numpy import genfromtxt
my_data = genfromtxt('my_file.csv', delimiter=',')

SNIPPET:
np.genfromtxt('myfile.csv',delimiter=',',dtype=None)

###########
QUERY:number of columns of csv

GENERATED (& CHOSEN) SNIPPET:
len(df.columns)

SNIPPET:
for row in reader:
    content = list(row[i] for i in included_cols)
print content

SNIPPET:
import pandas as pd
df = pd.read_csv(csv_file)
saved_column = df.column_name #you can also use df['column_name']

SNIPPET:
df.shape[1]

SNIPPET:
import csv
from collections import defaultdict

columns = defaultdict(list) # each value in each column is appended to a list

with open('file.txt') as f:
    reader = csv.DictReader(f) # read rows into a dictionary format
    for row in reader: # read a row as {column1: value1, column2: value2,...}
        for (k,v) in row.items(): # go over each column name and value 
            columns[k].append(v) # append the value into the appropriate list
                                 # based on column name k

print(columns['name'])
print(columns['phone'])
print(columns['street'])

SNIPPET:
names = df.Names

SNIPPET:
import pandas as pd
df = pd.DataFrame({"pear": [1,2,3], "apple": [2,3,4], "orange": [3,4,5]})

len(df.columns)
3

MATCH:
import pandas as pd
df = pd.DataFrame({"pear": [1,2,3], "apple": [2,3,4], "orange": [3,4,5]})

len(df.columns)
3

SNIPPET:
for row in reader:
        content = list(row[i] for i in included_cols)
        print content

###########
QUERY:write csv `output_f` to file "output/output.csv"

GENERATED (& CHOSEN) SNIPPET:
output_f.to_csv('output/output.csv', index=False)

SNIPPET:
function exportTableToCSV($table, filename) {

    var $rows = $table.find('tr:has(td),tr:has(th)'),

        // Temporary delimiter characters unlikely to be typed by keyboard
        // This is to avoid accidentally splitting the actual contents
        tmpColDelim = String.fromCharCode(11), // vertical tab character
        tmpRowDelim = String.fromCharCode(0), // null character

        // actual delimiter characters for CSV format
        colDelim = '","',
        rowDelim = '"\r\n"',

        // Grab text from table into CSV formatted string
        csv = '"' + $rows.map(function (i, row) {
            var $row = $(row), $cols = $row.find('td,th');

            return $cols.map(function (j, col) {
                var $col = $(col), text = $col.text();

                return text.replace(/"/g, '""'); // escape double quotes

            }).get().join(tmpColDelim);

        }).get().join(tmpRowDelim)
            .split(tmpRowDelim).join(rowDelim)
            .split(tmpColDelim).join(colDelim) + '"',



        // Data URI
        csvData = 'data:application/csv;charset=utf-8,' + encodeURIComponent(csv);

        console.log(csv);

        if (window.navigator.msSaveBlob) { // IE 10+
            //alert('IE' + csv);
            window.navigator.msSaveOrOpenBlob(new Blob([csv], {type: "text/plain;charset=utf-8;"}), "csvname.csv")
        } 
        else {
            $(this).attr({ 'download': filename, 'href': csvData, 'target': '_blank' }); 
        }
}

// This must be a hyperlink
$("#xx").on('click', function (event) {

    exportTableToCSV.apply(this, [$('#projectSpreadsheet'), 'export.csv']);

    // IF CSV, don't do event.preventDefault() or return false
    // We actually need this to be a typical hyperlink
});

SNIPPET:
<script type="text/javascript" src="jquery-1.3.2.js" ></script>

<script type="text/javascript" src="html2CSV.js" ></script>

SNIPPET:
<input value="Export as CSV 2" type="button" onclick="$('#example1').table2CSV({header:['prefix','Employee Name','Contact']})">

SNIPPET:
<a href="#" id="xx" style="text-decoration:none;color:#000;background-color:#ddd;border:1px solid #ccc;padding:8px;">Export Table data into Excel</a>

SNIPPET:
<table id="example1" border="1"  style="background-color:#FFFFCC" width="0%" cellpadding="3" cellspacing="3">

    <tr>

        <th>Title</th>

        <th>Name</th>

        <th>Phone</th>

    </tr>

    <tr>

        <td>Mr.</td>

        <td>John</td>

        <td>07868785831</td>

    </tr>

    <tr>

        <td>Miss</td>

        <td><i>Linda</i></td>

        <td>0141-2244-5566</td>

    </tr>

    <tr>

        <td>Master</td>

        <td>Jack</td>

        <td>0142-1212-1234</td>

    </tr>

    <tr>

        <td>Mr.</td>

        <td>Bush</td>

        <td>911-911-911</td>

    </tr>

</table>

SNIPPET:
csv = []
for row in $('#sometable tr')
  csv.push ("\"#{col.innerText}\"" for col in $(row).find('td,th')).join(',')
output = csv.join("\n")

SNIPPET:
jQuery.fn.table2CSV = function(options) {
    var options = jQuery.extend({
        separator: ',',
        header: [],
        delivery: 'popup' // popup, value
    },
    options);

    var csvData = [];
    var headerArr = [];
    var el = this;

    //header
    var numCols = options.header.length;
    var tmpRow = []; // construct header avalible array

    if (numCols > 0) {
        for (var i = 0; i < numCols; i++) {
            tmpRow[tmpRow.length] = formatData(options.header[i]);
        }
    } else {
        $(el).filter(':visible').find('th').each(function() {
            if ($(this).css('display') != 'none') tmpRow[tmpRow.length] = formatData($(this).html());
        });
    }

    row2CSV(tmpRow);

    // actual data
    $(el).find('tr').each(function() {
        var tmpRow = [];
        $(this).filter(':visible').find('td').each(function() {
            if ($(this).css('display') != 'none') tmpRow[tmpRow.length] = formatData($(this).html());
        });
        row2CSV(tmpRow);
    });
    if (options.delivery == 'popup') {
        var mydata = csvData.join('\n');
        return popup(mydata);
    } else {
        var mydata = csvData.join('\n');
        return mydata;
    }

    function row2CSV(tmpRow) {
        var tmp = tmpRow.join('') // to remove any blank rows
        // alert(tmp);
        if (tmpRow.length > 0 && tmp != '') {
            var mystr = tmpRow.join(options.separator);
            csvData[csvData.length] = mystr;
        }
    }
    function formatData(input) {
        // replace " with “
        var regexp = new RegExp(/["]/g);
        var output = input.replace(regexp, "“");
        //HTML
        var regexp = new RegExp(/\<[^\<]+\>/g);
        var output = output.replace(regexp, "");
        if (output == "") return '';
        return '"' + output + '"';
    }
    function popup(data) {
        var generator = window.open('', 'csv', 'height=400,width=600');
        generator.document.write('<html><head><title>CSV</title>');
        generator.document.write('</head><body >');
        generator.document.write('<textArea cols=70 rows=15 wrap="off" >');
        generator.document.write(data);
        generator.document.write('</textArea>');
        generator.document.write('</body></html>');
        generator.document.close();
        return true;
    }
};

###########
QUERY:check if file `output_file` exists

GENERATED (& CHOSEN) SNIPPET:
os.path.exists(output_file)

SNIPPET:
import os, errno

try:
    os.makedirs(directory)
except OSError as e:
    if e.errno != errno.EEXIST:
        raise

SNIPPET:
try:
    os.makedirs("path/to/directory")
except FileExistsError:
    # directory already exists
    pass

SNIPPET:
import os
if not os.path.exists(directory):
    os.makedirs(directory)

SNIPPET:
from pathlib import Path

my_file = Path("/path/to/file")
if my_file.is_file():
    # file exists

SNIPPET:
os.makedirs("path/to/directory", exist_ok=True)  # succeeds even if directory exists.

SNIPPET:
from pathlib import Path
Path("/my/directory").mkdir(parents=True, exist_ok=True)

SNIPPET:
import os.path
os.path.isfile(fname)

###########
QUERY:add entry to json file

GENERATED (& CHOSEN) SNIPPET:
json.dumps(entry, content_type='application/json')

SNIPPET:
data[0]['f'] = var

SNIPPET:
with open('data.txt', 'a') as outfile:
    json.dump(hostDict, outfile, indent=2)

SNIPPET:
with open('data.txt', 'a') as outfile:
    for hostDict in ....:
        json.dump(hostDict, outfile)
        outfile.write('\n')

SNIPPET:
with open(DATA_FILENAME, mode='w', encoding='utf-8') as f:
    json.dump([], f)

SNIPPET:
import json
import os

filename = 'data.json'
with open(filename, 'r') as f:
    data = json.load(f)
    data['id'] = 134 # <--- add `id` value.

os.remove(filename)
with open(filename, 'w') as f:
    json.dump(data, f, indent=4)

SNIPPET:
import json

with open('data.json', 'r+') as f:
    data = json.load(f)
    data['id'] = 134 # <--- add `id` value.
    f.seek(0)        # <--- should reset file position to the beginning.
    json.dump(data, f, indent=4)
    f.truncate()     # remove remaining part

SNIPPET:
with open(DATA_FILENAME, mode='w', encoding='utf-8') as feedsjson:
    entry = {'name': args.name, 'url': args.url}
    feeds.append(entry)
    json.dump(feeds, feedsjson)

###########
QUERY:GET request to "https://jsonplaceholder.typicode.com/posts" with argument userId

GENERATED (& CHOSEN) SNIPPET:
r = requests.get('https://jsonplaceholder.typicode.com/posts', params=userid)

SNIPPET:
import sys
print (sys.argv)

SNIPPET:
headers = {"W-Token": "Ilovemyboss"}
data = [
    {
        'url': '/rest/shifts',
        'params': {'user_id': 0, 'other_stuff': 'value'},
        'method': 'post',
    },
    {
        'url': '/rest/shifts',
        'params': {'user_id': 1,'other_stuff': 'value'},
        'method':'post',
    },
]
requests.post(url, json=data, headers=headers)

SNIPPET:
input_var = input("Enter something: ")
print ("you entered " + input_var)

SNIPPET:
var = raw_input("Please enter something: ")
print "you entered", var

SNIPPET:
var = input("Please enter something: ")
print("You entered: " + var)

SNIPPET:
text = raw_input("prompt")  # Python 2
text = input("prompt")  # Python 3

SNIPPET:
headers = {'Content-Type': 'application/json', 'Accept':'application/json'}

###########
QUERY:print format

GENERATED (& CHOSEN) SNIPPET:
print('<unk> %s, <unk>' % (1, 2))

SNIPPET:
x = np.random.random(10)
with np.printoptions(precision=3, suppress=True):
    print(x)
    # [ 0.073  0.461  0.689  0.754  0.624  0.901  0.049  0.582  0.557  0.348]

SNIPPET:
print(x)    
# [ 0.07334334  0.46132615  0.68935231  0.75379645  0.62424021  0.90115836
#   0.04879837  0.58207504  0.55694118  0.34768638]

SNIPPET:
import numpy as np
import contextlib

@contextlib.contextmanager
def printoptions(*args, **kwargs):
    original = np.get_printoptions()
    np.set_printoptions(*args, **kwargs)
    try:
        yield
    finally: 
        np.set_printoptions(**original)

x = np.random.random(10)
with printoptions(precision=3, suppress=True):
    print(x)
    # [ 0.073  0.461  0.689  0.754  0.624  0.901  0.049  0.582  0.557  0.348]

SNIPPET:
np.set_printoptions(formatter={'float': '{: 0.3f}'.format})
print(x)

SNIPPET:
[ 0.078  0.480  0.413  0.830  0.776  0.102  0.513  0.462  0.335  0.712]

SNIPPET:
y=np.array([1.5e-10,1.5,1500])
print(y)
# [  1.500e-10   1.500e+00   1.500e+03]
np.set_printoptions(suppress=True)
print(y)
# [    0.      1.5  1500. ]

SNIPPET:
import numpy as np
x=np.random.random(10)
print(x)
# [ 0.07837821  0.48002108  0.41274116  0.82993414  0.77610352  0.1023732
#   0.51303098  0.4617183   0.33487207  0.71162095]

np.set_printoptions(precision=3)
print(x)
# [ 0.078  0.48   0.413  0.83   0.776  0.102  0.513  0.462  0.335  0.712]

###########
QUERY:exit program

GENERATED (& CHOSEN) SNIPPET:
sys.exit()

SNIPPET:
>>> print (exit)
Use exit() or Ctrl-Z plus Return to exit
>>>

SNIPPET:
raise SystemExit

SNIPPET:
import sys, traceback

def main():
    try:
        do main program stuff here
        ....
    except KeyboardInterrupt:
        print "Shutdown requested...exiting"
    except Exception:
        traceback.print_exc(file=sys.stdout)
    sys.exit(0)

if __name__ == "__main__":
    main()

SNIPPET:
#do stuff
if this == that:
  quit()

SNIPPET:
import sys
sys.exit()

MATCH:
import sys
sys.exit()

SNIPPET:
>>> print (quit)
Use quit() or Ctrl-Z plus Return to exit
>>>

CONALA MATCH:
sys.exit()

CONALA EXACT MATCH:
sys.exit()

CONALA MATCH:
sys.exit()

CONALA EXACT MATCH:
sys.exit()

CONALA MATCH:
sys.exit()

CONALA EXACT MATCH:
sys.exit()

###########
QUERY:get current time

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.now().time()

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

MATCH:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
>>> current_milli_time()
1378761833768

SNIPPET:
import time

current_milli_time = lambda: int(round(time.time() * 1000))

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
import time
millis = int(round(time.time() * 1000))
print millis

CONALA MATCH:
datetime.datetime.now()

CONALA MATCH:
datetime.datetime.now().time()

CONALA EXACT MATCH:
datetime.datetime.now().time()

###########
QUERY:load csv data

GENERATED (& CHOSEN) SNIPPET:
pd.read_csv(data, header=None)

SNIPPET:
1.0, 2, 3
4, 5.5, 6

import numpy as np
np.genfromtxt('myfile.csv',delimiter=',')

SNIPPET:
array([(1.0, 2.0, 3), (4.0, 5.5, 6)], 
      dtype=[('f0', '<f8'), ('f1', '<f8'), ('f2', '<i4')])

SNIPPET:
spark.read.csv(
    "some_input_file.csv", header=True, mode="DROPMALFORMED", schema=schema
)

SNIPPET:
array([[ 1. ,  2. ,  3. ],
       [ 4. ,  5.5,  6. ]])

SNIPPET:
import pandas as pd
df=pd.read_csv('myfile.csv', sep=',',header=None)
df.values
array([[ 1. ,  2. ,  3. ],
       [ 4. ,  5.5,  6. ]])

SNIPPET:
from numpy import genfromtxt
my_data = genfromtxt('my_file.csv', delimiter=',')

SNIPPET:
np.genfromtxt('myfile.csv',delimiter=',',dtype=None)

###########
QUERY:How to generate random letter

GENERATED (& CHOSEN) SNIPPET:
"""""".join(choice(ascii_uppercase) for i in range(12))

SNIPPET:
>>> range(4) # range create a list of 'n' numbers
[0, 1, 2, 3]
>>> ['elem' for _ in range(4)] # we use range to create 4 times 'elem'
['elem', 'elem', 'elem', 'elem']

SNIPPET:
>>> string.ascii_uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.digits
'0123456789'
>>> string.ascii_uppercase + string.digits
'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

SNIPPET:
>>> import string
>>> import random
>>> def id_generator(size=6, chars=string.ascii_uppercase + string.digits):
...    return ''.join(random.choice(chars) for _ in range(size))
...
>>> id_generator()
'G5G74W'
>>> id_generator(3, "6793YUIO")
'Y3U'

SNIPPET:
''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(N))

SNIPPET:
''.join(random.choices(string.ascii_uppercase + string.digits, k=N))

SNIPPET:
''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))

SNIPPET:
>>> random.choice("abcde")
'a'
>>> random.choice("abcde")
'd'
>>> random.choice("abcde")
'b'

###########
QUERY:How to generate random int in range between 1 and 20

GENERATED (& CHOSEN) SNIPPET:
print(random.randint(0, 9))

SNIPPET:
import random
random.sample(range(100), 10)

SNIPPET:
>>> import random
>>> random.sample(range(1, 100), 3)
[77, 52, 45]

SNIPPET:
def random_dates(start, end, n=10):

    start_u = start.value//10**9
    end_u = end.value//10**9

    return pd.to_datetime(np.random.randint(start_u, end_u, n), unit='s')

SNIPPET:
all_lines = f1.readlines()
for i in range(50):
    lines = random.sample(all_lines, 40)

SNIPPET:
Random number:    1  2  3  4  5  6  7  8
Result:           1  2  3  4  7  8  9 10

SNIPPET:
>>> try:
...   random.sample(range(1, 2), 3)
... except ValueError:
...   print('Sample size exceeded population size.')
... 
Sample size exceeded population size

SNIPPET:
import random
numbers = range(a,b) + range(c,d)
r = random.choice(numbers)

CONALA MATCH:
randint(0, 9)

###########
QUERY:get current path

GENERATED (& CHOSEN) SNIPPET:
os.path.abspath(os.path)

SNIPPET:
import pathlib
pathlib.Path().absolute()

SNIPPET:
import os

print("Path at terminal when executing this file")
print(os.getcwd() + "\n")

print("This file path, relative to os.getcwd()")
print(__file__ + "\n")

print("This file full path (following symlinks)")
full_path = os.path.realpath(__file__)
print(full_path + "\n")

print("This file directory and name")
path, filename = os.path.split(full_path)
print(path + ' --> ' + filename + "\n")

print("This file directory only")
print(os.path.dirname(full_path))

SNIPPET:
import pathlib
pathlib.Path(__file__).parent.absolute()

SNIPPET:
import os
os.path.dirname(os.path.abspath(__file__))

SNIPPET:
import os
os.path.abspath(os.getcwd())

SNIPPET:
import os
cwd = os.getcwd()

SNIPPET:
import os 
dir_path = os.path.dirname(os.path.realpath(__file__))

###########
QUERY:get date and time one week from now

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.combine(datetime.date.today(), datetime.timedelta(hours=3))

SNIPPET:
from datetime import date
from datetime import datetime

dt = datetime.combine(date.today(), datetime.min.time())

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
>>> import datetime
>>> datetime.datetime.today()
datetime.datetime(2012, 3, 23, 23, 24, 55, 173504)
>>> datetime.datetime.today().weekday()
4

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
from datetime import datetime, timedelta

d = datetime.today() - timedelta(days=days_to_subtract)

###########
QUERY:get time and date one week from now

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.combine(datetime.date.today(), datetime.timedelta(hours=3))

SNIPPET:
from datetime import datetime
datetime.now().strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
>>> import datetime
>>> datetime.date(2010, 6, 16).isocalendar()[1]
24

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
>>> from datetime import datetime
>>> str(datetime.now())
'2011-05-03 17:45:35.177000'

###########
QUERY:trim the heading and trailing whitespaces and blank lines for all text files

GENERATED (& CHOSEN) SNIPPET:
re.split('\n\\s*\n', string)

SNIPPET:
>>> "  Hello\n".strip(" ")
'Hello\n'

SNIPPET:
>>> 'test string \n \r\n\n\r \n\n'.rstrip()
'test string'

SNIPPET:
def strip_one_space(s):
    if s.endswith(" "): s = s[:-1]
    if s.startswith(" "): s = s[1:]
    return s

>>> strip_one_space("   Hello ")
'  Hello'

SNIPPET:
>>> s = "   \n\r\n  \n  abc   def \n\r\n  \n  "
>>> s.strip()
'abc   def'
>>> s.lstrip()
'abc   def \n\r\n  \n  '
>>> s.rstrip()
'   \n\r\n  \n  abc   def'

SNIPPET:
>>> ' Hello '.strip()
'Hello'
>>> ' Hello'.strip()
'Hello'
>>> 'Bob has a cat'.strip()
'Bob has a cat'
>>> '   Hello   '.strip()  # ALL consecutive spaces at both ends removed
'Hello'

SNIPPET:
>>> 'test string\n'.rstrip()
'test string'

SNIPPET:
>>> 'test string \n \r\n\n\r \n\n'.rstrip('\n')
'test string \n \r\n\n\r '

###########
QUERY:generate random number

GENERATED (& CHOSEN) SNIPPET:
random.randint(0, 7)

SNIPPET:
>>> import random
>>> random.sample(range(1, 100), 3)
[77, 52, 45]

SNIPPET:
import random
random.uniform(0, 1)

SNIPPET:
from random import randint
randint(100, 999)  # randint is inclusive at both ends

SNIPPET:
>>> try:
...   random.sample(range(1, 2), 3)
... except ValueError:
...   print('Sample size exceeded population size.')
... 
Sample size exceeded population size

SNIPPET:
random.randint(a, b)

SNIPPET:
from random import randrange
print(randrange(10))

SNIPPET:
import random
print(random.randint(0,9))

SNIPPET:
from random import randrange, uniform

# randrange gives you an integral value
irand = randrange(0, 10)

# uniform gives you a floating-point value
frand = uniform(0, 10)

###########
QUERY:sort a list

GENERATED (& CHOSEN) SNIPPET:
sorted(list, key=lambda x: x[1])

SNIPPET:
from operator import itemgetter
newlist = sorted(list_to_be_sorted, key=itemgetter('name'))

SNIPPET:
data.sort(key=lambda tup: tup[1])  # sorts in place

SNIPPET:
s = sorted(s, key = lambda x: (x[1], x[2]))

SNIPPET:
sorted_by_second = sorted(data, key=lambda tup: tup[1])

SNIPPET:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])

SNIPPET:
import operator
s = sorted(s, key = operator.itemgetter(1, 2))

SNIPPET:
newlist = sorted(l, key=itemgetter('name'), reverse=True)

###########
QUERY:change directory to "data"

GENERATED (& CHOSEN) SNIPPET:
os.chdir('data')

SNIPPET:
import subprocess # just to call an arbitrary command e.g. 'ls'

# enter the directory like this:
with cd("~/Library"):
   # we are in ~/Library
   subprocess.call("ls")

# outside the context manager we are back wherever we started.

SNIPPET:
export PYTHONPATH=/path/to/my/library:$PYTHONPATH

SNIPPET:
>>> import os
>>> os.getcwd()
'/home/user'
>>> os.chdir("/tmp/")
>>> os.getcwd()
'/tmp'

SNIPPET:
import os

os.chdir(path)

SNIPPET:
import os

class cd:
    """Context manager for changing the current working directory"""
    def __init__(self, newPath):
        self.newPath = os.path.expanduser(newPath)

    def __enter__(self):
        self.savedPath = os.getcwd()
        os.chdir(self.newPath)

    def __exit__(self, etype, value, traceback):
        os.chdir(self.savedPath)

SNIPPET:
os.chdir(path)

SNIPPET:
set PYTHONPATH=%PYTHONPATH%;C:\My_python_lib

###########
QUERY:check if directory exists

GENERATED (& CHOSEN) SNIPPET:
os.path.exists()

SNIPPET:
import os, errno

try:
    os.makedirs(directory)
except OSError as e:
    if e.errno != errno.EEXIST:
        raise

SNIPPET:
try:
    os.makedirs("path/to/directory")
except FileExistsError:
    # directory already exists
    pass

SNIPPET:
import os
if not os.path.exists(directory):
    os.makedirs(directory)

SNIPPET:
from pathlib import Path

my_file = Path("/path/to/file")
if my_file.is_file():
    # file exists

SNIPPET:
os.makedirs("path/to/directory", exist_ok=True)  # succeeds even if directory exists.

SNIPPET:
from pathlib import Path
Path("/my/directory").mkdir(parents=True, exist_ok=True)

SNIPPET:
import os.path
os.path.isfile(fname)

###########
QUERY:pandas dataframe groupby column

GENERATED (& CHOSEN) SNIPPET:
df.groupby('User').agg({'A': x.mean})

SNIPPET:
In [11]: df.fillna(-1)
Out[11]: 
   a   b
0  1   4
1  2  -1
2  3   6

In [12]: df.fillna(-1).groupby('b').sum()
Out[12]: 
    a
b    
-1  2
4   1
6   3

SNIPPET:
In [11]: df.groupby(['col5', 'col2']).size()
Out[11]:
col5  col2
1     A       1
      D       3
2     B       2
3     A       3
      C       1
4     B       1
5     B       2
6     B       1
dtype: int64

SNIPPET:
df.groupby(['Fruit','Name']).sum()

Out[31]: 
               Number
Fruit   Name         
Apples  Bob        16
        Mike        9
        Steve      10
Grapes  Bob        35
        Tom        87
        Tony       15
Oranges Bob        67
        Mike       57
        Tom        15
        Tony        1

SNIPPET:
df.groupby(['Name', 'Fruit'])['Number'].agg('sum')

SNIPPET:
In [56]: df.groupby(['col5','col2']).size().reset_index().groupby('col2')[[0]].max()
Out[56]: 
      0
col2   
A     3
B     2
C     1
D     3

SNIPPET:
In [12]: df.groupby(['col5', 'col2']).size().groupby(level=1).max()
Out[12]:
col2
A       3
B       2
C       1
D       3
dtype: int64

SNIPPET:
df.groupby(['Fruit','Name'])['Number'].sum().reset_index()

Fruit   Name       Number
Apples  Bob        16
Apples  Mike        9
Apples  Steve      10
Grapes  Bob        35
Grapes  Tom        87
Grapes  Tony       15
Oranges Bob        67
Oranges Mike       57
Oranges Tom        15
Oranges Tony        1

###########
QUERY:how to draw scatter plot for data in csv file

GENERATED (& CHOSEN) SNIPPET:
plt.scatter(x, y, color='str_3')

SNIPPET:
def getColumn(filename, column):
    results = csv.reader(open(filename), delimiter="\t")
    return [result[column] for result in results]

SNIPPET:
ax1.plot(data['x'], data['y'], color='r', label='the data')

SNIPPET:
x,y
1,2
2,4
3,6
4,7
5,11
6,12
7,13
8,20
9,17
10,19

SNIPPET:
df  = pd.read_csv("data.csv")

SNIPPET:
import pandas as pd
import matplotlib.pyplot as plt
df  = pd.read_csv("data.csv")
df.plot()  # plots all columns against index
df.plot(kind='scatter',x='x',y='y') # scatter plot
df.plot(kind='density')  # estimate density function
# df.plot(kind='hist')  # histogram

SNIPPET:
import pandas as pd
from datetime import datetime
import csv
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
headers = ['Sensor Value','Date','Time']
df = pd.read_csv('C:/Users\Lala Rushan\Downloads\DataLog.CSV',names=headers)
print (df)

df['Date'] = df['Date'].map(lambda x: datetime.strptime(str(x), '%Y/%m/%d %H:%M:%S.%f'))
x = df['Date']
y = df['Sensor Value']

# plot
plt.plot(x,y)
# beautify the x-labels
plt.gcf().autofmt_xdate()

plt.show()

SNIPPET:
import numpy as np
data = np.genfromtxt('e:\dir1\datafile.csv', delimiter=',', skip_header=10,
                     skip_footer=10, names=['x', 'y', 'z'])

###########
QUERY:generate random int

GENERATED (& CHOSEN) SNIPPET:
random.randint(0, 7)

SNIPPET:
>>> import random
>>> random.sample(range(1, 100), 3)
[77, 52, 45]

SNIPPET:
df = pd.DataFrame(np.random.randint(0,100,size=(100, 4)), columns=list('ABCD'))

SNIPPET:
>>> try:
...   random.sample(range(1, 2), 3)
... except ValueError:
...   print('Sample size exceeded population size.')
... 
Sample size exceeded population size

SNIPPET:
random.randint(a, b)

SNIPPET:
>>> import string
>>> string.ascii_letters
'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> import random
>>> random.choice(string.ascii_letters)
'j'

SNIPPET:
from random import randrange
print(randrange(10))

SNIPPET:
import random
print(random.randint(0,9))

###########
QUERY:dictionary of characters and int

GENERATED (& CHOSEN) SNIPPET:
dict((k, 'b.') for k in of)

SNIPPET:
>>> ord('a')
97
>>> chr(97)
'a'
>>> chr(ord('a') + 3)
'd'
>>>

SNIPPET:
print [ord(char) - 96 for char in raw_input('Write Text: ').lower()]

SNIPPET:
input = raw_input('Write Text: ')
input = input.lower()
output = []
for character in input:
    number = ord(character) - 96
    output.append(number)
print output

SNIPPET:
>>> unichr(97)
u'a'
>>> unichr(1234)
u'\u04d2'

SNIPPET:
>>> ord(u'あ')
12354

SNIPPET:
>>> from collections import Counter
>>> Counter(['apple','red','apple','red','red','pear'])
Counter({'red': 3, 'apple': 2, 'pear': 1})

SNIPPET:
counts = dict()
for i in items:
  counts[i] = counts.get(i, 0) + 1

###########
QUERY:open csv

GENERATED (& CHOSEN) SNIPPET:
df = pd.read_csv('<unk>', header=None)

SNIPPET:
[('This is the first line', 'Line1'), ('This is the second line', 'Line2'), ('This is the third line', 'Line3')]

SNIPPET:
[['This is the first line', 'Line1'], ['This is the second line', 'Line2'], ['This is the third line', 'Line3']]

SNIPPET:
import csv

with open('file.csv', newline='') as f:
    reader = csv.reader(f)
    data = list(reader)

print(data)

SNIPPET:
import csv

with open('file.csv', newline='') as f:
    reader = csv.reader(f)
    data = [tuple(row) for row in reader]

print(data)

SNIPPET:
import csv

def getstuff(filename, criterion):
    with open(filename, "rb") as csvfile:
        datareader = csv.reader(csvfile)
        yield next(datareader)  # yield the header row
        count = 0
        for row in datareader:
            if row[3] == criterion:
                yield row
                count += 1
            elif count:
                # done when having read a consecutive series of rows 
                return

SNIPPET:
import csv
from itertools import dropwhile, takewhile

def getstuff(filename, criterion):
    with open(filename, "rb") as csvfile:
        datareader = csv.reader(csvfile)
        yield next(datareader)  # yield the header row
        # first row, plus any subsequent rows that match, then stop
        # reading altogether
        # Python 2: use `for row in takewhile(...): yield row` instead
        # instead of `yield from takewhile(...)`.
        yield from takewhile(
            lambda r: r[3] == criterion,
            dropwhile(lambda r: r[3] != criterion, datareader))
        return

SNIPPET:
import csv
with open('file.csv', 'rb') as f:
    reader = csv.reader(f)
    your_list = list(reader)

print your_list
# [['This is the first line', 'Line1'],
#  ['This is the second line', 'Line2'],
#  ['This is the third line', 'Line3']]

###########
QUERY:delete row in csv

GENERATED (& CHOSEN) SNIPPET:
np.delete(row, list(range(0, len(row) + 1, 2)), axis=1)

SNIPPET:
if any(row):

SNIPPET:
del r[2]
            wtr.writerow( r )

SNIPPET:
$ cat test.py 
import csv
with open('first.csv', 'rb') as inp, open('first_edit.csv', 'wb') as out:
    writer = csv.writer(out)
    for row in csv.reader(inp):
        if row[2] != " 0":
            writer.writerow(row)
$ cat first.csv 
6.5, 5.4, 0, 320
6.5, 5.4, 1, 320
$ python test.py 
$ cat first_edit.csv 
6.5, 5.4, 1, 320

SNIPPET:
if any(field.strip() for field in row):

SNIPPET:
import csv
with open('first.csv', 'rb') as inp, open('first_edit.csv', 'wb') as out:
    writer = csv.writer(out)
    for row in csv.reader(inp):
        if row[2] != "0":
            writer.writerow(row)

SNIPPET:
import csv
with open("source","rb") as source:
    rdr= csv.reader( source )
    with open("result","wb") as result:
        wtr= csv.writer( result )
        for r in rdr:
            wtr.writerow( (r[0], r[1], r[3], r[4]) )

SNIPPET:
row[2]!="0":

SNIPPET:
import pandas as pd
f=pd.read_csv("test.csv")
keep_col = ['day','month','lat','long']
new_f = f[keep_col]
new_f.to_csv("newFile.csv", index=False)

SNIPPET:
h1,h2,h3
a,b,c
d,e,f
g,h,i
j,k,l

SNIPPET:
in_iter= ( (r[0], r[1], r[3], r[4]) for r in rdr )
        wtr.writerows( in_iter )

SNIPPET:
with open('1.csv','r') as in_file, open('2.csv','w') as out_file:
    seen = set() # set for fast O(1) amortized lookup
    for line in in_file:
        if line in seen: continue # skip duplicate

        seen.add(line)
        out_file.write(line)

SNIPPET:
import csv
...

with open(in_fnam) as in_file:
    with open(out_fnam, 'w') as out_file:
        writer = csv.writer(out_file)
        for row in csv.reader(in_file):
            if row:
                writer.writerow(row)

SNIPPET:
import fileinput
seen = set() # set for fast O(1) amortized lookup
for line in fileinput.FileInput('1.csv', inplace=1):
    if line in seen: continue # skip duplicate

    seen.add(line)
    print line, # standard output is now redirected to the file

SNIPPET:
from more_itertools import unique_everseen
with open('1.csv','r') as f, open('2.csv','w') as out_file:
    out_file.writelines(unique_everseen(f))

###########
QUERY:rename files

GENERATED (& CHOSEN) SNIPPET:
os.rename(filename, filenames)

SNIPPET:
import glob, os

def rename(dir, pattern, titlePattern):
    for pathAndFilename in glob.iglob(os.path.join(dir, pattern)):
        title, ext = os.path.splitext(os.path.basename(pathAndFilename))
        os.rename(pathAndFilename, 
                  os.path.join(dir, titlePattern % title + ext))

SNIPPET:
rename(r'c:\temp\xx', r'*.doc', r'new(%s)')

SNIPPET:
import os

os.rename('a.txt', 'b.kml')

SNIPPET:
import os
old_file = os.path.join("directory", "a.txt")
new_file = os.path.join("directory", "b.kml")
os.rename(old_file, new_file)

SNIPPET:
import os
import shutil

os.rename("path/to/current/file.foo", "path/to/new/destination/for/file.foo")
shutil.move("path/to/current/file.foo", "path/to/new/destination/for/file.foo")
os.replace("path/to/current/file.foo", "path/to/new/destination/for/file.foo")

SNIPPET:
import os
[os.rename(f, f.replace('_', '-')) for f in os.listdir('.') if not f.startswith('.')]

SNIPPET:
$ ls
cheese_cheese_type.bar  cheese_cheese_type.foo
$ python
>>> import os
>>> for filename in os.listdir("."):
...  if filename.startswith("cheese_"):
...    os.rename(filename, filename[7:])
... 
>>> 
$ ls
cheese_type.bar  cheese_type.foo

###########
QUERY:http reques get html

GENERATED (& CHOSEN) SNIPPET:
requests.get(html, headers={1}.__class__())

SNIPPET:
import requests
import shutil

r = requests.get(settings.STATICMAP_URL.format(**data), stream=True)
if r.status_code == 200:
    with open(path, 'wb') as f:
        r.raw.decode_content = True
        shutil.copyfileobj(r.raw, f)

SNIPPET:
import urllib.request
contents = urllib.request.urlopen("http://example.com/foo/bar").read()

SNIPPET:
r = requests.get(settings.STATICMAP_URL.format(**data), stream=True)
if r.status_code == 200:
    with open(path, 'wb') as f:
        for chunk in r:
            f.write(chunk)

SNIPPET:
r = requests.get(settings.STATICMAP_URL.format(**data), stream=True)
if r.status_code == 200:
    with open(path, 'wb') as f:
        for chunk in r.iter_content(1024):
            f.write(chunk)

SNIPPET:
import requests
import logging

# These two lines enable debugging at httplib level (requests->urllib3->http.client)
# You will see the REQUEST, including HEADERS and DATA, and RESPONSE with HEADERS but without DATA.
# The only thing missing will be the response.body which is not logged.
try:
    import http.client as http_client
except ImportError:
    # Python 2
    import httplib as http_client
http_client.HTTPConnection.debuglevel = 1

# You must initialize logging, otherwise you'll not see debug output.
logging.basicConfig()
logging.getLogger().setLevel(logging.DEBUG)
requests_log = logging.getLogger("requests.packages.urllib3")
requests_log.setLevel(logging.DEBUG)
requests_log.propagate = True

requests.get('https://httpbin.org/headers')

SNIPPET:
$ python requests-logging.py 
INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): httpbin.org
send: 'GET /headers HTTP/1.1\r\nHost: httpbin.org\r\nAccept-Encoding: gzip, deflate, compress\r\nAccept: */*\r\nUser-Agent: python-requests/1.2.0 CPython/2.7.3 Linux/3.2.0-48-generic\r\n\r\n'
reply: 'HTTP/1.1 200 OK\r\n'
header: Content-Type: application/json
header: Date: Sat, 29 Jun 2013 11:19:34 GMT
header: Server: gunicorn/0.17.4
header: Content-Length: 226
header: Connection: keep-alive
DEBUG:requests.packages.urllib3.connectionpool:"GET /headers HTTP/1.1" 200 226

SNIPPET:
import urllib2
contents = urllib2.urlopen("http://example.com/foo/bar").read()

###########
QUERY:save table beautifulsoup

GENERATED (& CHOSEN) SNIPPET:
tr.findAll('td', style='tr')

SNIPPET:
for tr in soup.find_all('tr')[2:]:
    tds = tr.find_all('td')
    print "Nome: %s, Cognome: %s, Email: %s" % \
          (tds[0].text, tds[1].text, tds[2].text)

SNIPPET:
data = []
table = soup.find('table', attrs={'class':'lineItemsTable'})
table_body = table.find('tbody')

rows = table_body.find_all('tr')
for row in rows:
    cols = row.find_all('td')
    cols = [ele.text.strip() for ele in cols]
    data.append([ele for ele in cols if ele]) # Get rid of empty values

SNIPPET:
with open('output.txt', 'w') as f:
    for tr in soup.find_all('tr')[2:]:
        tds = tr.find_all('td')
        f.write("Nome: %s, Cognome: %s, Email: %s\n" % \
              (tds[0].text, tds[1].text, tds[2].text))

SNIPPET:
Nome:  Massimo, Cognome:  Allegri, Email:  Allegri.Massimo@alitalia.it
Nome:  Alessandra, Cognome:  Anastasia, Email:  Anastasia.Alessandra@alitalia.it
...

SNIPPET:
[ [u'1359711259', u'SRF', u'08/05/2013', u'5310 4 AVE', u'K', u'19', u'125.00', u'$'], 
  [u'7086775850', u'PAS', u'12/14/2013', u'3908 6th Ave', u'K', u'40', u'125.00', u'$'], 
  [u'7355010165', u'OMT', u'12/14/2013', u'3908 6th Ave', u'K', u'40', u'145.00', u'$'], 
  [u'4002488755', u'OMT', u'02/12/2014', u'NB 1ST AVE @ E 23RD ST', u'5', u'115.00', u'$'], 
  [u'7913806837', u'OMT', u'03/03/2014', u'5015 4th Ave', u'K', u'46', u'115.00', u'$'], 
  [u'5080015366', u'OMT', u'03/10/2014', u'EB 65TH ST @ 16TH AV E', u'7', u'50.00', u'$'], 
  [u'7208770670', u'OMT', u'04/08/2014', u'333 15th St', u'K', u'70', u'65.00', u'$'], 
  [u'$0.00\n\n\nPayment Amount:']
]

SNIPPET:
with open("output1.html", "w") as file:
    file.write(str(soup))

SNIPPET:
start = cols[1].find('a').string

###########
QUERY:regex []

GENERATED (& CHOSEN) SNIPPET:
re.sub('<unk>', '.', text)

SNIPPET:
import re
s = "Example String"
replaced = re.sub('[ES]', 'a', s)
print replaced

SNIPPET:
article = re.sub(r'(?is)</html>.+', '</html>', article)

SNIPPET:
import re

line = re.sub(
           r"(?i)^.*interfaceOpDataFile.*$", 
           "interfaceOpDataFile %s" % fileIn, 
           line
       )

SNIPPET:
['cat', 'wildcat', 'thundercat']

SNIPPET:
import re

mylist = ["dog", "cat", "wildcat", "thundercat", "cow", "hooo"]
r = re.compile(".*cat")
newlist = list(filter(r.match, mylist)) # Read Note
print(newlist)

SNIPPET:
import re

regex = re.compile(r"^.*interfaceOpDataFile.*$", re.IGNORECASE)
for line in some_file:
    line = regex.sub("interfaceOpDataFile %s" % fileIn, line)
    # do something with the updated line

SNIPPET:
filter(r.match, list)

###########
QUERY:rearrange dictionary keys into alphabetic order

GENERATED (& CHOSEN) SNIPPET:
sorted(list(keys.items()), key=lambda x: x[1])

SNIPPET:
keylist = mydict.keys()
keylist.sort()
for key in keylist:
    print "%s: %s" % (key, mydict[key])

SNIPPET:
In [13]: for k, v in od.items(): print(k, v)
   ....: 
1 89
2 3
3 0
4 5

SNIPPET:
>>> from collections import OrderedDict

>>> # regular unsorted dictionary
>>> d = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}

>>> # dictionary sorted by key -- OrderedDict(sorted(d.items()) also works
>>> OrderedDict(sorted(d.items(), key=lambda t: t[0]))
OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])

>>> # dictionary sorted by value
>>> OrderedDict(sorted(d.items(), key=lambda t: t[1]))
OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])

>>> # dictionary sorted by length of the key string
>>> OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))
OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])

SNIPPET:
mydict = {'carl':40,
          'alan':2,
          'bob':1,
          'danny':3}

for key in sorted(mydict):
    print "%s: %s" % (key, mydict[key])

SNIPPET:
In [1]: import collections

In [2]: d = {2:3, 1:89, 4:5, 3:0}

In [3]: od = collections.OrderedDict(sorted(d.items()))

In [4]: od
Out[4]: OrderedDict([(1, 89), (2, 3), (3, 0), (4, 5)])

SNIPPET:
alan: 2
bob: 1
carl: 40
danny: 3

SNIPPET:
In [11]: od[1]
Out[11]: 89

In [12]: od[3]
Out[12]: 0

In [13]: for k, v in od.iteritems(): print k, v
   ....: 
1 89
2 3
3 0
4 5

###########
QUERY:sort a list x into ascending order

GENERATED (& CHOSEN) SNIPPET:
sorted(var_1, key=sorted)

SNIPPET:
[x for _,x in sorted(zip(Y,X))]

SNIPPET:
data.sort(key=lambda tup: tup[1])  # sorts in place

SNIPPET:
[x for _, x in sorted(zip(Y,X), key=lambda pair: pair[0])]

SNIPPET:
sorted_by_second = sorted(data, key=lambda tup: tup[1])

SNIPPET:
from operator import itemgetter
data.sort(key=itemgetter(1))

SNIPPET:
X = ["a", "b", "c", "d", "e", "f", "g", "h", "i"]
Y = [ 0,   1,   1,    0,   1,   2,   2,   0,   1]

Z = [x for _,x in sorted(zip(Y,X))]
print(Z)  # ["a", "d", "h", "b", "c", "e", "i", "f", "g"]

SNIPPET:
>>> yx = zip(Y, X)
>>> yx
[(0, 'a'), (1, 'b'), (1, 'c'), (0, 'd'), (1, 'e'), (2, 'f'), (2, 'g'), (0, 'h'), (1, 'i')]
>>> yx.sort()
>>> yx
[(0, 'a'), (0, 'd'), (0, 'h'), (1, 'b'), (1, 'c'), (1, 'e'), (1, 'i'), (2, 'f'), (2, 'g')]
>>> x_sorted = [x for y, x in yx]
>>> x_sorted
['a', 'd', 'h', 'b', 'c', 'e', 'i', 'f', 'g']

###########
QUERY:sort a list into ascending order

GENERATED (& CHOSEN) SNIPPET:
sorted(list, key=sorted)

SNIPPET:
[x for _,x in sorted(zip(Y,X))]

SNIPPET:
data.sort(key=lambda tup: tup[1])  # sorts in place

SNIPPET:
[x for _, x in sorted(zip(Y,X), key=lambda pair: pair[0])]

SNIPPET:
sorted_by_second = sorted(data, key=lambda tup: tup[1])

SNIPPET:
from operator import itemgetter
data.sort(key=itemgetter(1))

SNIPPET:
X = ["a", "b", "c", "d", "e", "f", "g", "h", "i"]
Y = [ 0,   1,   1,    0,   1,   2,   2,   0,   1]

Z = [x for _,x in sorted(zip(Y,X))]
print(Z)  # ["a", "d", "h", "b", "c", "e", "i", "f", "g"]

SNIPPET:
>>> yx = zip(Y, X)
>>> yx
[(0, 'a'), (1, 'b'), (1, 'c'), (0, 'd'), (1, 'e'), (2, 'f'), (2, 'g'), (0, 'h'), (1, 'i')]
>>> yx.sort()
>>> yx
[(0, 'a'), (0, 'd'), (0, 'h'), (1, 'b'), (1, 'c'), (1, 'e'), (1, 'i'), (2, 'f'), (2, 'g')]
>>> x_sorted = [x for y, x in yx]
>>> x_sorted
['a', 'd', 'h', 'b', 'c', 'e', 'i', 'f', 'g']

###########
QUERY:sort list 'values' into ascending order

GENERATED (& CHOSEN) SNIPPET:
sorted(values, key=values.index)

SNIPPET:
from operator import itemgetter
newlist = sorted(list_to_be_sorted, key=itemgetter('name'))

SNIPPET:
data.sort(key=lambda tup: tup[1])  # sorts in place

SNIPPET:
sorted_by_second = sorted(data, key=lambda tup: tup[1])

SNIPPET:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])

SNIPPET:
>>> s = [2, 3, 1, 4, 5]
>>> sorted(range(len(s)), key=lambda k: s[k])
[2, 0, 1, 3, 4]
>>>

SNIPPET:
from operator import itemgetter
data.sort(key=itemgetter(1))

SNIPPET:
newlist = sorted(l, key=itemgetter('name'), reverse=True)

###########
QUERY:how to combine 2 lists into a dictionary

GENERATED (& CHOSEN) SNIPPET:
dict(zip(keys, values))

SNIPPET:
z = merge_two_dicts(x, y)

SNIPPET:
>>> z
{'a': 1, 'b': 3, 'c': 4}

SNIPPET:
def merge_two_dicts(x, y):
      z = x.copy()   # start with x's keys and values
      z.update(y)    # modifies z with y's keys and values & returns None
      return z

SNIPPET:
z = x | y          # NOTE: 3.9+ ONLY

SNIPPET:
x = {'a': 1, 'b': 2}
y = {'b': 3, 'c': 4}

SNIPPET:
z = {**x, **y}

CONALA MATCH:
dict(zip(keys, values))

CONALA EXACT MATCH:
dict(zip(keys, values))

###########
QUERY:client connection to url

GENERATED (& CHOSEN) SNIPPET:
print(self.status_code)

SNIPPET:
>>> from httplib2 import Http
>>> from urllib import urlencode
>>> h = Http()
>>> data = dict(name="Joe", comment="A test comment")
>>> resp, content = h.request("http://bitworking.org/news/223/Meet-Ares", "POST", urlencode(data))
>>> resp
{'status': '200', 'transfer-encoding': 'chunked', 'vary': 'Accept-Encoding,User-Agent',
 'server': 'Apache', 'connection': 'close', 'date': 'Tue, 31 Jul 2007 15:29:52 GMT', 
 'content-type': 'text/html'}

SNIPPET:
import socket

clientsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
clientsocket.connect(('localhost', 8089))
clientsocket.send('hello')

SNIPPET:
>>> print urllib.urlopen("http://www.stackoverflow.com").getcode()
>>> 200

SNIPPET:
import requests
url = 'https://...'
payload = {'key1': 'value1', 'key2': 'value2'}

# GET
r = requests.get(url)

# GET with params in URL
r = requests.get(url, params=payload)

# POST with form-encoded data
r = requests.post(url, data=payload)

# POST with JSON 
import json
r = requests.post(url, data=json.dumps(payload))

# Response, status etc
r.text
r.status_code

SNIPPET:
import urllib.request
print(urllib.request.urlopen("http://www.stackoverflow.com").getcode())
>>> 200

SNIPPET:
import socket

serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
serversocket.bind(('localhost', 8089))
serversocket.listen(5) # become a server socket, maximum 5 connections

while True:
    connection, address = serversocket.accept()
    buf = connection.recv(64)
    if len(buf) > 0:
        print buf
        break

SNIPPET:
host = socket.gethostname() #Get the local machine name
port = 12397 # Reserve a port for your service
s.bind((host,port)) #Bind to the port

###########
QUERY:list to dict

GENERATED (& CHOSEN) SNIPPET:
dict((k, ':') for k, v in list(d.items()))

SNIPPET:
{key: value for (key, value) in iterable}

SNIPPET:
import csv
toCSV = [{'name':'bob','age':25,'weight':200},
         {'name':'jim','age':31,'weight':180}]
keys = toCSV[0].keys()
with open('people.csv', 'w', newline='')  as output_file:
    dict_writer = csv.DictWriter(output_file, keys)
    dict_writer.writeheader()
    dict_writer.writerows(toCSV)

SNIPPET:
b = dict(zip(a[::2], a[1::2]))

SNIPPET:
from itertools import izip
i = iter(a)
b = dict(izip(i, i))

SNIPPET:
>>> keys = ['a', 'b', 'c']
>>> values = [1, 2, 3]
>>> dictionary = dict(zip(keys, values))
>>> print(dictionary)
{'a': 1, 'b': 2, 'c': 3}

SNIPPET:
dict((key, func(key)) for key in keys)

SNIPPET:
1) consumed from any iterable yielding pairs of keys/vals
dict(pairs)

2) "zip'ped" from two separate iterables of keys/vals
dict(zip(list_of_keys, list_of_values))

SNIPPET:
>>> from collections import Counter
>>> Counter(['apple','red','apple','red','red','pear'])
Counter({'red': 3, 'apple': 2, 'pear': 1})

CONALA MATCH:
list(d.items())

CONALA MATCH:
list(d.items())

###########
QUERY:save plot as image

GENERATED (& CHOSEN) SNIPPET:
plt.savefig('save')

SNIPPET:
plt.savefig('my_fig.png', dpi=my_dpi * 10)

SNIPPET:
plt.savefig('my_fig.png', dpi=my_dpi)

SNIPPET:
from matplotlib import pyplot as plt

plt.savefig('foo.png')
plt.savefig('foo.pdf')

SNIPPET:
plt.figure(figsize=(3.841, 7.195), dpi=100)
( your code ...)
plt.savefig('myfig.png', dpi=1000)

SNIPPET:
savefig('foo.png', bbox_inches='tight')

SNIPPET:
plt.figure(figsize=(800/my_dpi, 800/my_dpi), dpi=my_dpi)

SNIPPET:
import matplotlib.pyplot as plt
fig, ax = plt.subplots( nrows=1, ncols=1 )  # create figure & 1 axis
ax.plot([0,1,2], [10,20,3])
fig.savefig('path/to/save/image/to.png')   # save the figure to file
plt.close(fig)    # close the figure window

###########
QUERY:print date and time in GMT in 24hr format

GENERATED (& CHOSEN) SNIPPET:
parser.strftime('%Y-%m-%d %H:%M:%S', gmtime())

SNIPPET:
for date in mylist :
    print str(date)

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
>>> from datetime import datetime

SNIPPET:
print today.strftime('We are the %d, %b %Y')
>>> 'We are the 22, Nov 2008'

SNIPPET:
import time
print time.strftime("%Y-%m-%d %H:%M")

SNIPPET:
import datetime
mylist = []
today = datetime.date.today()
mylist.append(today)
print mylist[0] # print the date object, not the container ;-)
2008-11-22

# It's better to always use str() because :

print "This is a new day : ", mylist[0] # will work
>>> This is a new day : 2008-11-22

print "This is a new day : " + mylist[0] # will crash
>>> cannot concatenate 'str' and 'datetime.date' objects

print "This is a new day : " + str(mylist[0]) 
>>> This is a new day : 2008-11-22

SNIPPET:
import datetime
f"{datetime.datetime.now():%Y-%m-%d}"
>>> '2017-06-15'

SNIPPET:
import datetime
print datetime.datetime.now().strftime("%Y-%m-%d %H:%M")

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
print "We are the {:%d, %b %Y}".format(today)
>>> 'We are the 22, Nov 2008'

CONALA MATCH:
strftime('%Y-%m-%d %H:%M:%S', gmtime())

###########
QUERY:remove first column from csv file

GENERATED (& CHOSEN) SNIPPET:
df = pd.read_csv('my.csv', header=None)

SNIPPET:
name,phone,street
Bob,0893,32 Silly
James,000,400 McHilly
Smithers,4442,23 Looped St.

SNIPPET:
for row in reader:
    content = list(row[i] for i in included_cols)
print content

SNIPPET:
import pandas as pd
df = pd.read_csv(csv_file)
saved_column = df.column_name #you can also use df['column_name']

SNIPPET:
import csv
from collections import defaultdict

columns = defaultdict(list) # each value in each column is appended to a list

with open('file.txt') as f:
    reader = csv.DictReader(f) # read rows into a dictionary format
    for row in reader: # read a row as {column1: value1, column2: value2,...}
        for (k,v) in row.items(): # go over each column name and value 
            columns[k].append(v) # append the value into the appropriate list
                                 # based on column name k

print(columns['name'])
print(columns['phone'])
print(columns['street'])

SNIPPET:
names = df.Names

SNIPPET:
>>> 
['Bob', 'James', 'Smithers']
['0893', '000', '4442']
['32 Silly', '400 McHilly', '23 Looped St.']

SNIPPET:
for row in reader:
        content = list(row[i] for i in included_cols)
        print content

###########
QUERY:copy directory to another directory

GENERATED (& CHOSEN) SNIPPET:
shutil.copy2(directory, 'ignore_errors')

SNIPPET:
import os
import shutil
src_files = os.listdir(src)
for file_name in src_files:
    full_file_name = os.path.join(src, file_name)
    if os.path.isfile(full_file_name):
        shutil.copy(full_file_name, dest)

SNIPPET:
from distutils.dir_util import copy_tree
copy_tree("/a/b/c", "/x/y/z")

SNIPPET:
import shutil, errno

def copyanything(src, dst):
    try:
        shutil.copytree(src, dst)
    except OSError as exc: # python >2.5
        if exc.errno == errno.ENOTDIR:
            shutil.copy(src, dst)
        else: raise

SNIPPET:
import shutil
import os

source = '/path/to/source_folder'
dest1 = '/path/to/dest_folder'

files = os.listdir(source)

for f in files:
    shutil.move(source+f, dest1)

SNIPPET:
import os, shutil
def copytree(src, dst, symlinks=False, ignore=None):
    for item in os.listdir(src):
        s = os.path.join(src, item)
        d = os.path.join(dst, item)
        if os.path.isdir(s):
            shutil.copytree(s, d, symlinks, ignore)
        else:
            shutil.copy2(s, d)

SNIPPET:
def copytree(src, dst, symlinks=False, ignore=None):
    if not os.path.exists(dst):
        os.makedirs(dst)
    for item in os.listdir(src):
        s = os.path.join(src, item)
        d = os.path.join(dst, item)
        if os.path.isdir(s):
            copytree(s, d, symlinks, ignore)
        else:
            if not os.path.exists(d) or os.stat(s).st_mtime - os.stat(d).st_mtime > 1:
                shutil.copy2(s, d)

SNIPPET:
from distutils.dir_util import copy_tree

# copy subdirectory example
fromDirectory = "/a/b/c"
toDirectory = "/x/y/z"

copy_tree(fromDirectory, toDirectory)

###########
QUERY:rename file with regex

GENERATED (& CHOSEN) SNIPPET:
re.sub('<unk>', '\\1', text)

SNIPPET:
rename -n 's/(\w+) - (\d{1})x(\d{2}).*$/S0$2E$3\.srt/' *.srt

SNIPPET:
$ for old in ./images*.png; do
    new=$(echo $old | sed -e 's/\.png$/test.png/')
    mv -v "$old" "$new"
  done

SNIPPET:
rename 's/^images\/(.+)/test\/$1.png/s' images/*.png

SNIPPET:
import os

os.rename('a.txt', 'b.kml')

SNIPPET:
import os
old_file = os.path.join("directory", "a.txt")
new_file = os.path.join("directory", "b.kml")
os.rename(old_file, new_file)

SNIPPET:
import shutil

shutil.move('a.txt', 'b.kml')

SNIPPET:
for x in *.png;do mv $x test/${x%.png}test.png;done

###########
QUERY:format time

GENERATED (& CHOSEN) SNIPPET:
"""time""".strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
import time

start = time.time()
print("hello")
end = time.time()
print(end - start)

SNIPPET:
for date in mylist :
    print str(date)

SNIPPET:
print today.strftime('We are the %d, %b %Y')
>>> 'We are the 22, Nov 2008'

SNIPPET:
from timeit import default_timer as timer

start = timer()
# ...
end = timer()
print(end - start) # Time in seconds, e.g. 5.38091952400282

SNIPPET:
import datetime
mylist = []
today = datetime.date.today()
mylist.append(today)
print mylist[0] # print the date object, not the container ;-)
2008-11-22

# It's better to always use str() because :

print "This is a new day : ", mylist[0] # will work
>>> This is a new day : 2008-11-22

print "This is a new day : " + mylist[0] # will crash
>>> cannot concatenate 'str' and 'datetime.date' objects

print "This is a new day : " + str(mylist[0]) 
>>> This is a new day : 2008-11-22

SNIPPET:
import datetime
f"{datetime.datetime.now():%Y-%m-%d}"
>>> '2017-06-15'

SNIPPET:
print "We are the {:%d, %b %Y}".format(today)
>>> 'We are the 22, Nov 2008'

###########
QUERY:import time

GENERATED (& CHOSEN) SNIPPET:
now = datetime.datetime.now().strftime('%H:%M:%S')

SNIPPET:
import time

start = time.time()
print("hello")
end = time.time()
print(end - start)

SNIPPET:
import time
start_time = time.time()
main()
print("--- %s seconds ---" % (time.time() - start_time))

SNIPPET:
from timeit import default_timer as timer

start = timer()
# ...
end = timer()
print(end - start) # Time in seconds, e.g. 5.38091952400282

SNIPPET:
--- 0.764891862869 seconds ---

SNIPPET:
$ time python yourprogram.py

SNIPPET:
import atexit
from time import clock

def secondsToStr(t):
    return "%d:%02d:%02d.%03d" % \
        reduce(lambda ll,b : divmod(ll[0],b) + ll[1:],
            [(t*1000,),1000,60,60])

line = "="*40
def log(s, elapsed=None):
    print line
    print secondsToStr(clock()), '-', s
    if elapsed:
        print "Elapsed time:", elapsed
    print line
    print

def endlog():
    end = clock()
    elapsed = end-start
    log("End Program", secondsToStr(elapsed))

def now():
    return secondsToStr(clock())

start = clock()
atexit.register(endlog)
log("Start Program")

SNIPPET:
$ time -v python yourprogram.py
    Command being timed: "python3 yourprogram.py"
    User time (seconds): 0.08
    System time (seconds): 0.02
    Percent of CPU this job got: 98%
    Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.10
    Average shared text size (kbytes): 0
    Average unshared data size (kbytes): 0
    Average stack size (kbytes): 0
    Average total size (kbytes): 0
    Maximum resident set size (kbytes): 9480
    Average resident set size (kbytes): 0
    Major (requiring I/O) page faults: 0
    Minor (reclaiming a frame) page faults: 1114
    Voluntary context switches: 0
    Involuntary context switches: 22
    Swaps: 0
    File system inputs: 0
    File system outputs: 0
    Socket messages sent: 0
    Socket messages received: 0
    Signals delivered: 0
    Page size (bytes): 4096
    Exit status: 0

CONALA MATCH:
datetime.datetime.now()

CONALA MATCH:
now = datetime.datetime.now().strftime('%H:%M:%S')

CONALA EXACT MATCH:
now = datetime.datetime.now().strftime('%H:%M:%S')

###########
QUERY:read file

GENERATED (& CHOSEN) SNIPPET:
with open('file.txt') as f:
    f = open(os.path.join(__location__, 'rb'))

SNIPPET:
with open('Path/to/file', 'r') as content_file:
    content = content_file.read()

SNIPPET:
f = open("myfile", "rb")
try:
    byte = f.read(1)
    while byte != "":
        # Do stuff with byte.
        byte = f.read(1)
finally:
    f.close()

SNIPPET:
with open('filename') as f:
    lines = [line.rstrip() for line in f]

SNIPPET:
with open("file.txt") as file_in:
    lines = []
    for line in file_in:
        lines.append(line)

SNIPPET:
with open('data.txt', 'r') as file:
    data = file.read().replace('\n', '')

SNIPPET:
with open(filename) as f:
    content = f.readlines()
# you may also want to remove whitespace characters like `\n` at the end of each line
content = [x.strip() for x in content]

SNIPPET:
with open('filename') as f:
    lines = f.readlines()

###########
QUERY:iterating files in a folder

GENERATED (& CHOSEN) SNIPPET:
for dirname, dirnames, filenames in os.walk(files):
    pass

SNIPPET:
['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]

SNIPPET:
from os import walk

f = []
for (dirpath, dirnames, filenames) in walk(mypath):
    f.extend(filenames)
    break

SNIPPET:
import os
 arr = os.listdir()
 print(arr)

 >>> ['$RECYCLE.BIN', 'work.txt', '3ebooks.txt', 'documents']

SNIPPET:
import glob
print(glob.glob("/home/adam/*.txt"))

SNIPPET:
from os import listdir
from os.path import isfile, join
onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]

SNIPPET:
import glob

mylist = [f for f in glob.glob("*.txt")]

SNIPPET:
import glob

txtfiles = []
for file in glob.glob("*.txt"):
    txtfiles.append(file)

###########
QUERY:pandas calculate mean

GENERATED (& CHOSEN) SNIPPET:
df.groupby(np.arange(len(mean)) // 2 + 1, axis=1).mean()

SNIPPET:
In [5]: df.groupby('StationID')['BiasTemp'].mean()
Out[5]:
StationID
BB            5.0
KEOPS         2.5
SS0279       15.0
Name: BiasTemp, dtype: float64

SNIPPET:
In [479]: df
Out[479]: 
         ID  birthyear    weight
0    619040       1962  0.123123
1    600161       1963  0.981742
2  25602033       1963  1.312312
3    624870       1987  0.942120

In [480]: df["weight"].mean()
Out[480]: 0.83982437500000007

SNIPPET:
In [5]: df.groupby(df.index).apply(lambda x: np.average(x.wt, weights=x.value))
Out[5]: 
Date
01/01/2012    0.791667
01/02/2012    0.722222
dtype: float64

SNIPPET:
df['value'].expanding().mean()

SNIPPET:
In [4]: df.groupby('StationID', as_index=False)['BiasTemp'].mean()
Out[4]:
  StationID  BiasTemp
0        BB       5.0
1     KEOPS       2.5
2    SS0279      15.0

SNIPPET:
s.expanding().mean()

SNIPPET:
In [1]: import numpy as np

In [2]: import pandas as pd

In [3]: index = pd.Index(['01/01/2012','01/01/2012','01/01/2012','01/02/2012','01/02/2012'], name='Date')

In [4]: df = pd.DataFrame({'ID':[100,101,102,201,202],'wt':[.5,.75,1,.5,1],'value':[60,80,100,100,80]},index=index)

###########
QUERY:pandas read from csv

GENERATED (& CHOSEN) SNIPPET:
pd.read_csv('<unk>', sep='')

SNIPPET:
# Dataframes implement the Pandas API
import dask.dataframe as dd
df = dd.read_csv('s3://.../2018-*-*.csv')

SNIPPET:
import pandas as pd
pd.read_csv("../data_folder/data.csv")

SNIPPET:
import pandas as pd
from io import StringIO
df = pd.read_csv(StringIO("csv string..."))

SNIPPET:
>>> import numpy as np, pandas as pd
>>> import io, pkgutil
>>> wells = pkgutil.get_data('pymc.examples', 'data/wells.dat')
>>> type(wells)
<class 'bytes'>
>>> df = pd.read_csv(io.BytesIO(wells), encoding='utf8', sep=" ", index_col="id", dtype={"switch": np.int8})
>>> df.head()
    switch  arsenic       dist  assoc  educ
id                                         
1        1     2.36  16.826000      0     0
2        1     0.71  47.321999      0     0
3        0     2.07  20.966999      0    10
4        1     1.15  21.486000      0    12
5        1     1.10  40.874001      1    14

[5 rows x 5 columns]

SNIPPET:
chunks=pd.read_table('aphro.csv',chunksize=1000000,sep=';',\
       names=['lat','long','rf','date','slno'],index_col='slno',\
       header=None,parse_dates=['date'])

df=pd.DataFrame()
%time df=pd.concat(chunk.groupby(['lat','long',chunk['date'].map(lambda x: x.year)])['rf'].agg(['sum']) for chunk in chunks)

SNIPPET:
chunksize = 10 ** 6
for chunk in pd.read_csv(filename, chunksize=chunksize):
    process(chunk)

SNIPPET:
import os
import boto3
import pandas as pd
import sys

if sys.version_info[0] < 3: 
    from StringIO import StringIO # Python 2.x
else:
    from io import StringIO # Python 3.x

# get your credentials from environment variables
aws_id = os.environ['AWS_ID']
aws_secret = os.environ['AWS_SECRET']

client = boto3.client('s3', aws_access_key_id=aws_id,
        aws_secret_access_key=aws_secret)

bucket_name = 'my_bucket'

object_key = 'my_file.csv'
csv_obj = client.get_object(Bucket=bucket_name, Key=object_key)
body = csv_obj['Body']
csv_string = body.read().decode('utf-8')

df = pd.read_csv(StringIO(csv_string))

###########
QUERY:format output to 2 decimal

GENERATED (& CHOSEN) SNIPPET:
"""[{0}, {1}, {2}]""".format(1, 2, num=3)

SNIPPET:
answer = str(round(answer, 2))

SNIPPET:
float("{:.2f}".format(13.949999999999999))

SNIPPET:
>>> from math import pi  # pi ~ 3.141592653589793
>>> '{0:.2f}'.format(pi)
'3.14'

SNIPPET:
>>> x = 13.949999999999999999
>>> x
13.95
>>> g = float("{:.2f}".format(x))
>>> g
13.95
>>> x == g
True
>>> h = round(x, 2)
>>> h
13.95
>>> x == h
True

SNIPPET:
>>> 125650429603636838/(2**53)
13.949999999999999

>>> 234042163/(2**24)
13.949999988079071

>>> a = 13.946
>>> print(a)
13.946
>>> print("%.2f" % a)
13.95
>>> round(a,2)
13.949999999999999
>>> print("%.2f" % round(a, 2))
13.95
>>> print("{:.2f}".format(a))
13.95
>>> print("{:.2f}".format(round(a, 2)))
13.95
>>> print("{:.15f}".format(round(a, 2)))
13.949999999999999

SNIPPET:
>>> f'{pi:.2f}'
'3.14'

SNIPPET:
"{:.2f}".format(13.949999999999999)

###########
QUERY:pair characters in `characters` and numbers in `numbers`

GENERATED (& CHOSEN) SNIPPET:
numbers = list(zip(characters, numbers))

SNIPPET:
>>> import re
>>> re.sub('\D', '', 'aas30dsa20')
'3020'

SNIPPET:
>>> list(string.ascii_lowercase)
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

SNIPPET:
>>> ''.join(filter(str.isdigit, 'aas30dsa20'))
'3020'

SNIPPET:
>>> filter(str.isdigit, 'aas30dsa20')
'3020'

SNIPPET:
>>> list(map(chr, range(97, 123))) #or list(map(chr, range(ord('a'), ord('z')+1)))
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

SNIPPET:
>>> help(string) # on Python 3
....
DATA
    ascii_letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    ascii_lowercase = 'abcdefghijklmnopqrstuvwxyz'
    ascii_uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    digits = '0123456789'
    hexdigits = '0123456789abcdefABCDEF'
    octdigits = '01234567'
    printable = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'
    punctuation = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
    whitespace = ' \t\n\r\x0b\x0c'

SNIPPET:
>>> import string
>>> string.ascii_lowercase
'abcdefghijklmnopqrstuvwxyz'

###########
QUERY:delete a column in csv

GENERATED (& CHOSEN) SNIPPET:
df.drop('value', axis=1, inplace=True)

SNIPPET:
df = df.drop(columns, axis=1)

SNIPPET:
df.drop('column_name', axis=1, inplace=True)

SNIPPET:
df = df.drop(df.columns[[0, 1, 3]], axis=1)  # df.columns is zero-based pd.Index

SNIPPET:
del df['column_name']

SNIPPET:
df = df.drop('column_name', 1)

SNIPPET:
columns = ['Col1', 'Col2', ...]
df.drop(columns, inplace=True, axis=1)

SNIPPET:
df.drop(['column_nameA', 'column_nameB'], axis=1, inplace=True)

###########
QUERY:save dataframe to csv

GENERATED (& CHOSEN) SNIPPET:
pd.merge(csv, csv, sep='\t')

SNIPPET:
Color,Number
red,22
blue,10

SNIPPET:
df.to_csv(file_name, sep='\t', encoding='utf-8')

SNIPPET:
,Color,Number
0,red,22
1,blue,10

SNIPPET:
Color  Number
0   red     22
1  blue     10

SNIPPET:
df.to_csv(file_name, sep='\t')

SNIPPET:
df.to_csv(file_name, encoding='utf-8', index=False)

SNIPPET:
df.toPandas().to_csv('mycsv.csv')

###########
QUERY:reformat date

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.now().strftime('%Y-%m-%d')

SNIPPET:
for date in mylist :
    print str(date)

SNIPPET:
print today.strftime('We are the %d, %b %Y')
>>> 'We are the 22, Nov 2008'

SNIPPET:
import time
print time.strftime("%Y-%m-%d %H:%M")

SNIPPET:
import datetime
mylist = []
today = datetime.date.today()
mylist.append(today)
print mylist[0] # print the date object, not the container ;-)
2008-11-22

# It's better to always use str() because :

print "This is a new day : ", mylist[0] # will work
>>> This is a new day : 2008-11-22

print "This is a new day : " + mylist[0] # will crash
>>> cannot concatenate 'str' and 'datetime.date' objects

print "This is a new day : " + str(mylist[0]) 
>>> This is a new day : 2008-11-22

SNIPPET:
import datetime
f"{datetime.datetime.now():%Y-%m-%d}"
>>> '2017-06-15'

SNIPPET:
import datetime
print datetime.datetime.now().strftime("%Y-%m-%d %H:%M")

SNIPPET:
print "We are the {:%d, %b %Y}".format(today)
>>> 'We are the 22, Nov 2008'

CONALA MATCH:
datetime.datetime.now()

###########
QUERY:create list "a_list"

GENERATED (& CHOSEN) SNIPPET:
a = [a_list]

SNIPPET:
[e] * n

SNIPPET:
# 2.X only. Use list(range(10)) in 3.X.
>>> l = range(10)
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

SNIPPET:
>>> def display():
...     s1 = []
...     for i in range(9): # This is just to tell you how to create a list.
...         s1.append(i)
...     return s1
... 
>>> print display()
[0, 1, 2, 3, 4, 5, 6, 7, 8]

SNIPPET:
>>> l[1] = 5
>>> l
[None, 5, None, None, None, None, None, None, None, None]

SNIPPET:
>>> def display():
...     return [x**2 for x in range(9)]
... 
>>> print display()
[0, 1, 4, 9, 16, 25, 36, 49, 64]

SNIPPET:
>>> l = [None] * 10
>>> l
[None, None, None, None, None, None, None, None, None, None]

SNIPPET:
>>> timeit.timeit('itertools.repeat(0, 10)', 'import itertools', number = 1000000)
0.37095273281943264
>>> timeit.timeit('[0] * 10', 'import itertools', number = 1000000)
0.5577236771712819

###########
QUERY:create dictionary

GENERATED (& CHOSEN) SNIPPET:
dict((k, list(v.values())[k]) for k in ('utf-8', '16'))

SNIPPET:
new_dict = dict()

SNIPPET:
x = {}
x['a'] = 1

SNIPPET:
{key: value for (key, value) in iterable}

SNIPPET:
d = {k:v for k, v in iterable}

SNIPPET:
dict((key, func(key)) for key in keys)

SNIPPET:
new_dict = {}

SNIPPET:
1) consumed from any iterable yielding pairs of keys/vals
dict(pairs)

2) "zip'ped" from two separate iterables of keys/vals
dict(zip(list_of_keys, list_of_values))

###########
QUERY:copy column from "data.csv" file to another "output.csv"

GENERATED (& CHOSEN) SNIPPET:
output.csv['data.csv'] = pd.data.csv(data.csv)

SNIPPET:
import pandas as pd
pd.read_csv('input.csv', header=None).T.to_csv('output.csv', header=False, index=False)

SNIPPET:
import csv
from itertools import izip
a = izip(*csv.reader(open("input.csv", "rb")))
csv.writer(open("output.csv", "wb")).writerows(a)

SNIPPET:
import csv

date_reader = csv.reader(open('Date.csv', 'rb'))
price_reader = csv.reader(open('Price.csv', 'rb'))
writer = csv.writer(open('NewData.csv', 'wb'))
for date_row in date_reader:
    price_row = price_reader.next()
    writer.writerow(date_row + [price_row[1]])

SNIPPET:
a = [(1, 2, 3),
     (4, 5, 6),
     (7, 8, 9)]
zip(*a)
# [(1, 4, 7),
#  (2, 5, 8),
#  (3, 6, 9)]

SNIPPET:
import os, sys
target = '/path/to/target'
src1 = '/path/to/source1.csv'
src2 = '/path/to/source2.csv'
tf = open(target, 'a')
tf.write(open(src1).read())
tf.write(open(src2).read())
tf.close()

SNIPPET:
ID, Date, Price
0,"Jan 22, 2016",27.89
1,"Jan 21, 2016",26.80
2,"Jan 20, 2016",26.78
3,"Jan 19, 2016",26.00

SNIPPET:
import csv
reader = csv.reader(open('output.csv', 'rb'))
reader1 = csv.reader(open('output1.csv', 'rb'))
writer = csv.writer(open('appended_output.csv', 'wb'))
for row in reader:
    row1 = reader1.next()
    writer.writerow(row + row1)

###########
QUERY:new line

GENERATED (& CHOSEN) SNIPPET:
mmap.write('\n')

SNIPPET:
>>> 'test string \n \r\n\n\r \n\n'.rstrip()
'test string'

SNIPPET:
a = dostuff(blahblah1, blahblah2, blahblah3, blahblah4, blahblah5, 
            blahblah6, blahblah7)

SNIPPET:
>>> s = "   \n\r\n  \n  abc   def \n\r\n  \n  "
>>> s.strip()
'abc   def'
>>> s.lstrip()
'abc   def \n\r\n  \n  '
>>> s.rstrip()
'   \n\r\n  \n  abc   def'

SNIPPET:
a = '1' + '2' + '3' + \
    '4' + '5'

SNIPPET:
>>> 'test string\n'.rstrip()
'test string'

SNIPPET:
>>> 'test string \n \r\n\n\r \n\n'.rstrip('\n')
'test string \n \r\n\n\r '

SNIPPET:
if a == True and \
   b == False

###########
QUERY:read csv file using pandas

GENERATED (& CHOSEN) SNIPPET:
pd.read_csv('<unk>', sep=',', header=None)

SNIPPET:
import pandas as pd
import boto3

bucket = "yourbucket"
file_name = "your_file.csv"

s3 = boto3.client('s3') 
# 's3' is a key word. create connection to S3 using default config and all buckets within S3

obj = s3.get_object(Bucket= bucket, Key= file_name) 
# get object and file (key) from bucket

initial_df = pd.read_csv(obj['Body']) # 'Body' is a key word

SNIPPET:
encoding = "cp1252"
encoding = "ISO-8859-1"

SNIPPET:
import pandas as pd
data = pd.read_csv('file_name.csv', encoding='utf-8')

SNIPPET:
import pandas as pd
print pd.read_csv('value.txt')

        Date    price  factor_1  factor_2
0  2012-06-11  1600.20     1.255     1.548
1  2012-06-12  1610.02     1.258     1.554
2  2012-06-13  1618.07     1.249     1.552
3  2012-06-14  1624.40     1.253     1.556
4  2012-06-15  1626.15     1.258     1.552
5  2012-06-16  1626.15     1.263     1.558
6  2012-06-17  1626.15     1.264     1.572

SNIPPET:
import pandas as pd
df = pd.read_csv('file_name.csv', engine='python')

SNIPPET:
file_encoding = 'cp1252'        # set file_encoding to the file encoding (utf8, latin1, etc.)
pd.read_csv(input_file_and_path, ..., encoding=file_encoding)

SNIPPET:
import os
import boto3
import pandas as pd
import sys

if sys.version_info[0] < 3: 
    from StringIO import StringIO # Python 2.x
else:
    from io import StringIO # Python 3.x

# get your credentials from environment variables
aws_id = os.environ['AWS_ID']
aws_secret = os.environ['AWS_SECRET']

client = boto3.client('s3', aws_access_key_id=aws_id,
        aws_secret_access_key=aws_secret)

bucket_name = 'my_bucket'

object_key = 'my_file.csv'
csv_obj = client.get_object(Bucket=bucket_name, Key=object_key)
body = csv_obj['Body']
csv_string = body.read().decode('utf-8')

df = pd.read_csv(StringIO(csv_string))

###########
QUERY:check if string has specific pattern

GENERATED (& CHOSEN) SNIPPET:
re.findall('\\[(.*?)\\]', s)

SNIPPET:
pattern = re.compile(r'\d\$,')
if pattern.findall(s):
    print('Found')
else
    print('Not found')

SNIPPET:
s = "This be a string"
if s.find("is") == -1:
    print("No 'is' here!")
else:
    print("Found 'is' in the string.")

SNIPPET:
'$' in s        # found
'$' not in s    # not found

# original answer given, but less Pythonic than the above...
s.find('$')==-1 # not found
s.find('$')!=-1 # found

SNIPPET:
import re
pattern = re.compile("^([A-Z][0-9]+)+$")
pattern.match(string)

SNIPPET:
if "blah" not in somestring: 
    continue

SNIPPET:
chars = set('0123456789$,')
if any((c in chars) for c in s):
    print('Found')
else:
    print('Not Found')

SNIPPET:
if word in mystring: 
   print 'success'

###########
QUERY:regex dd-mm-yy

GENERATED (& CHOSEN) SNIPPET:
re.findall('\\d+', regex)

SNIPPET:
function validateDate(testdate) {
    var date_regex = /^(0[1-9]|1[0-2])\/(0[1-9]|1\d|2\d|3[01])\/(19|20)\d{2}$/ ;
    return date_regex.test(testdate);
}

SNIPPET:
^(?:(?:31(\/|-|\.)(?:0?[13578]|1[02]|(?:Jan|Mar|May|Jul|Aug|Oct|Dec)))\1|(?:(?:29|30)(\/|-|\.)(?:0?[1,3-9]|1[0-2]|(?:Jan|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})$|^(?:29(\/|-|\.)(?:0?2|(?:Feb))\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\d|2[0-8])(\/|-|\.)(?:(?:0?[1-9]|(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep))|(?:1[0-2]|(?:Oct|Nov|Dec)))\4(?:(?:1[6-9]|[2-9]\d)?\d{2})$

SNIPPET:
import datetime
dd = datetime.datetime.strptime(date,'%y%m%d')
if dd.year > 2005:
   dd = dd.replace(year=dd.year-100)

SNIPPET:
(^(((0[1-9]|1[0-9]|2[0-8])[\/](0[1-9]|1[012]))|((29|30|31)[\/](0[13578]|1[02]))|((29|30)[\/](0[4,6,9]|11)))[\/](19|[2-9][0-9])\d\d$)|(^29[\/]02[\/](19|[2-9][0-9])(00|04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96)$)

SNIPPET:
import datetime

print datetime.datetime.strptime('2010-08-27', '%Y-%m-%d')
print datetime.datetime.strptime('2010-15-27', '%Y-%m-%d')

SNIPPET:
2010-08-27 00:00:00
Traceback (most recent call last):
  File "./x.py", line 6, in <module>
    print datetime.datetime.strptime('2010-15-27', '%Y-%m-%d')
  File "/usr/lib/python2.7/_strptime.py", line 325, in _strptime
    (data_string, format))
ValueError: time data '2010-15-27' does not match format '%Y-%m-%d'

SNIPPET:
function validateDate(testdate) {
    var date_regex = /^\d{2}\/\d{2}\/\d{4}$/ ;
    return date_regex.test(testdate);
}

###########
QUERY:read csv

GENERATED (& CHOSEN) SNIPPET:
df = pd.read_csv('my.csv', header=None)

SNIPPET:
import csv

# Define data
data = [
    (1, "A towel,", 1.0),
    (42, " it says, ", 2.0),
    (1337, "is about the most ", -1),
    (0, "massively useful thing ", 123),
    (-2, "an interstellar hitchhiker can have.", 3),
]

# Write CSV file
with open("test.csv", "wt") as fp:
    writer = csv.writer(fp, delimiter=",")
    # writer.writerow(["your", "header", "foo"])  # write header
    writer.writerows(data)

# Read CSV file
with open("test.csv") as fp:
    reader = csv.reader(fp, delimiter=",", quotechar='"')
    # next(reader, None)  # skip the headers
    data_read = [row for row in reader]

print(data_read)

SNIPPET:
[['1', 'A towel,', '1.0'],
 ['42', ' it says, ', '2.0'],
 ['1337', 'is about the most ', '-1'],
 ['0', 'massively useful thing ', '123'],
 ['-2', 'an interstellar hitchhiker can have.', '3']]

SNIPPET:
if batch:
    do_something(batch)

SNIPPET:
import pandas as pd

# Read the CSV into a pandas data frame (df)
#   With a df you can do many things
#   most important: visualize data with Seaborn
df = pd.read_csv('myfile.csv', sep=',')
print(df)

# Or export it in many ways, e.g. a list of tuples
tuples = [tuple(x) for x in df.values]

# or export it as a list of dicts
dicts = df.to_dict().values()

SNIPPET:
yourstring= '"ABC", "XYZ,MNO", "KLM"\n"ABC", "MN"\n"ABC", "123", "10", "OPPA GANGNAM STYLE", "LADY"'

import csv
import io

class MyDialect(csv.Dialect):
    strict = True
    skipinitialspace = True
    quoting = csv.QUOTE_ALL
    delimiter = ','
    quotechar = '"'
    lineterminator = '\n'


b = io.StringIO(yourstring)
r = csv.reader(b, MyDialect())

for i in r:
    print len(i), ':',' @ '.join(i)

SNIPPET:
import mpu.io
data = mpu.io.read('example.csv', delimiter=',', quotechar='"', skiprows=None)
mpu.io.write('example.csv', data)

SNIPPET:
1,"A towel,",1.0
42," it says, ",2.0
1337,is about the most ,-1
0,massively useful thing ,123
-2,an interstellar hitchhiker can have.,3

###########
QUERY:newline space

GENERATED (& CHOSEN) SNIPPET:
""" """.rstrip('\r\n')

SNIPPET:
sys.stdout.flush()

SNIPPET:
>>> for i in range(10):
...     print i,
... else:
...     print
...
0 1 2 3 4 5 6 7 8 9
>>>

SNIPPET:
import sys
sys.stdout.write('.')

SNIPPET:
print('.', end='', flush=True)

SNIPPET:
print('.', end='')

SNIPPET:
print('a', 'b', 'c', sep='')

SNIPPET:
from __future__ import print_function

###########
QUERY:findall

GENERATED (& CHOSEN) SNIPPET:
re.findall('<unk>', 'раз')

SNIPPET:
>>> help(str.find)
Help on method_descriptor:

find(...)
    S.find(sub [,start [,end]]) -> int

SNIPPET:
def find_all(a_str, sub):
    start = 0
    while True:
        start = a_str.find(sub, start)
        if start == -1: return
        yield start
        start += len(sub) # use start += 1 to find overlapping matches

list(find_all('spam spam spam spam', 'spam')) # [0, 5, 10, 15]

SNIPPET:
import re
regex = ur"\[P\] (.+?) \[/P\]+?"
line = "President [P] Barack Obama [/P] met Microsoft founder [P] Bill Gates [/P], yesterday."
person = re.findall(regex, line)
print(person)

SNIPPET:
[m.start() for m in re.finditer('(?=tt)', 'ttt')]
#[0, 1]

SNIPPET:
import re
[m.start() for m in re.finditer('test', 'test test test test')]
#[0, 5, 10, 15]

SNIPPET:
search = 'tt'
[m.start() for m in re.finditer('(?=%s)(?!.{1,%d}%s)' % (search, len(search)-1, search), 'ttt')]
#[1]

SNIPPET:
['Barack Obama', 'Bill Gates']

###########
QUERY:generate 100 random lower-cased leters

GENERATED (& CHOSEN) SNIPPET:
random.choice(range(100), args=(100, 100))

SNIPPET:
>>> range(4) # range create a list of 'n' numbers
[0, 1, 2, 3]
>>> ['elem' for _ in range(4)] # we use range to create 4 times 'elem'
['elem', 'elem', 'elem', 'elem']

SNIPPET:
>>> string.ascii_uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.digits
'0123456789'
>>> string.ascii_uppercase + string.digits
'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'

SNIPPET:
>>> import string
>>> import random
>>> def id_generator(size=6, chars=string.ascii_uppercase + string.digits):
...    return ''.join(random.choice(chars) for _ in range(size))
...
>>> id_generator()
'G5G74W'
>>> id_generator(3, "6793YUIO")
'Y3U'

SNIPPET:
''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(N))

SNIPPET:
''.join(random.choices(string.ascii_uppercase + string.digits, k=N))

SNIPPET:
''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))

SNIPPET:
>>> random.choice("abcde")
'a'
>>> random.choice("abcde")
'd'
>>> random.choice("abcde")
'b'

###########
QUERY:generate random numbers between 1-20 inclusive

GENERATED (& CHOSEN) SNIPPET:
print(random.randint(0, 50))

SNIPPET:
import random
random.sample(range(100), 10)

SNIPPET:
>>> import random
>>> random.sample(range(1, 100), 3)
[77, 52, 45]

SNIPPET:
>>> try:
...   random.sample(range(1, 2), 3)
... except ValueError:
...   print('Sample size exceeded population size.')
... 
Sample size exceeded population size

SNIPPET:
random.randint(a, b)

SNIPPET:
all_lines = f1.readlines()
for i in range(50):
    lines = random.sample(all_lines, 40)

SNIPPET:
from random import randrange
print(randrange(10))

SNIPPET:
import random
print(random.randint(0,9))

###########
QUERY:Given list `letters` and `integers`, create a dicitonary such that the values in `letters` are keys and values in `integers` are values

GENERATED (& CHOSEN) SNIPPET:
letters = [(x + y) for x, y in zip(letters, integers)]

SNIPPET:
{key: value for (key, value) in iterable}

SNIPPET:
>>> newdict = {1:0, 2:0, 3:0}
>>> [*newdict]
[1, 2, 3]

SNIPPET:
for key in newdict.keys():
  print(key)

SNIPPET:
%timeit [*newdict]
1000000 loops, best of 3: 249 ns per loop

%timeit list(newdict)
1000000 loops, best of 3: 508 ns per loop

%timeit [k for k in newdict]
1000000 loops, best of 3: 574 ns per loop

SNIPPET:
dict.items()

SNIPPET:
dict((key, func(key)) for key in keys)

SNIPPET:
1) consumed from any iterable yielding pairs of keys/vals
dict(pairs)

2) "zip'ped" from two separate iterables of keys/vals
dict(zip(list_of_keys, list_of_values))

###########
QUERY:print `dic` sorted by keys

GENERATED (& CHOSEN) SNIPPET:
print(sorted(list(dic.items()), key=tuple))

SNIPPET:
keylist = mydict.keys()
keylist.sort()
for key in keylist:
    print "%s: %s" % (key, mydict[key])

SNIPPET:
In [13]: for k, v in od.items(): print(k, v)
   ....: 
1 89
2 3
3 0
4 5

SNIPPET:
>>> from collections import OrderedDict

>>> # regular unsorted dictionary
>>> d = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}

>>> # dictionary sorted by key -- OrderedDict(sorted(d.items()) also works
>>> OrderedDict(sorted(d.items(), key=lambda t: t[0]))
OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])

>>> # dictionary sorted by value
>>> OrderedDict(sorted(d.items(), key=lambda t: t[1]))
OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])

>>> # dictionary sorted by length of the key string
>>> OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))
OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])

SNIPPET:
mydict = {'carl':40,
          'alan':2,
          'bob':1,
          'danny':3}

for key in sorted(mydict):
    print "%s: %s" % (key, mydict[key])

SNIPPET:
In [1]: import collections

In [2]: d = {2:3, 1:89, 4:5, 3:0}

In [3]: od = collections.OrderedDict(sorted(d.items()))

In [4]: od
Out[4]: OrderedDict([(1, 89), (2, 3), (3, 0), (4, 5)])

SNIPPET:
alan: 2
bob: 1
carl: 40
danny: 3

SNIPPET:
In [11]: od[1]
Out[11]: 89

In [12]: od[3]
Out[12]: 0

In [13]: for k, v in od.iteritems(): print k, v
   ....: 
1 89
2 3
3 0
4 5

SNIPPET:
for key, value in mydic.iteritems() :
    print key, value

###########
QUERY:open a csv file `data.csv` and read the data

GENERATED (& CHOSEN) SNIPPET:
df = pd.read_csv('data.csv', sep=',', header=None)

SNIPPET:
Data = namedtuple("Data", next(reader))

SNIPPET:
('col2', 'col3')
('empId1', '241682-27638-USD-CIGGNT ')
('empId2', '241682-27638-USD-OCGGINT ')
('empId3', '241942-37190-USD-GGDIV ')
('empId4', '241942-37190-USD-CHYOF ')
('empId5', '241942-37190-USD-EQPL ')
('empId6', '241942-37190-USD-INT ')
('empId7', '242066-15343-USD-CYJOF ')
('empId8', '242066-15343-USD-CYJOF ')
('empId9', '242066-15343-USD-CYJOF ')
('empId10', '241942-37190-USD-GGDIV ')

SNIPPET:
next(reader)

SNIPPET:
import pandas as pd
print pd.read_csv('value.txt')

        Date    price  factor_1  factor_2
0  2012-06-11  1600.20     1.255     1.548
1  2012-06-12  1610.02     1.258     1.554
2  2012-06-13  1618.07     1.249     1.552
3  2012-06-14  1624.40     1.253     1.556
4  2012-06-15  1626.15     1.258     1.552
5  2012-06-16  1626.15     1.263     1.558
6  2012-06-17  1626.15     1.264     1.572

SNIPPET:
import csv
from collections import namedtuple
from itertools import imap

with open("data_file.txt", mode="rb") as infile:
    reader = csv.reader(infile)
    Data = namedtuple("Data", next(reader))  # get names from column headers
    for data in imap(Data._make, reader):
        print data.foo
        # ...further processing of a line...

SNIPPET:
import csv
from collections import namedtuple

with open("data_file.txt", newline="") as infile:
    reader = csv.reader(infile)
    Data = namedtuple("Data", next(reader))  # get names from column headers
    for data in map(Data._make, reader):
        print(data.foo)
        # ...further processing of a line...

SNIPPET:
import csv

path = 'c:\\temp\\'

file=open( path +"xyz.CSV", "r")
reader = csv.reader(file)
for line in reader:
    t=line[1],line[2]
    print(t)

###########
QUERY:delete first row from dataframe `df`

GENERATED (& CHOSEN) SNIPPET:
df = df.drop('get_title')

SNIPPET:
df.drop('column_name', axis=1, inplace=True)

SNIPPET:
df = df.drop(df.columns[[0, 1, 3]], axis=1)  # df.columns is zero-based pd.Index

SNIPPET:
df = df.drop('column_name', 1)

SNIPPET:
del df['column_name']

SNIPPET:
In [31]: df_test.iloc[0]
Out[31]: 
ATime     1.2
X         2.0
Y        15.0
Z         2.0
Btime     1.2
C        12.0
D        25.0
E        12.0
Name: 0, dtype: float64

SNIPPET:
df.drop(['column_nameA', 'column_nameB'], axis=1, inplace=True)

SNIPPET:
df = df[df.line_race != 0]

###########
QUERY:delete first and last row from the dataframe `df`

GENERATED (& CHOSEN) SNIPPET:
df = df.loc[-1]

SNIPPET:
df = df[df.score > 50]

SNIPPET:
df[df['column name'].map(len) < 2]

SNIPPET:
df = pd.DataFrame({'a':range(1,5), 'b':['a','b','c','d']})
df2 = df.iloc[[0, -1]]

print df2

   a  b
0  1  a
3  4  d

SNIPPET:
%%timeit
test = pd.DataFrame({'x': np.random.randn(int(1e6))})
test = test[test.x < 0]
# 54.5 ms ± 2.02 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

%%timeit
test = pd.DataFrame({'x': np.random.randn(int(1e6))})
test.drop(test[test.x > 0].index, inplace=True)
# 201 ms ± 17.9 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

%%timeit
test = pd.DataFrame({'x': np.random.randn(int(1e6))})
test = test.drop(test[test.x > 0].index)
# 194 ms ± 7.03 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

SNIPPET:
df.drop(df.tail(n).index,inplace=True) # drop last n rows

SNIPPET:
df = df.iloc[3:]

SNIPPET:
df.drop(df.head(n).index,inplace=True) # drop first n rows

###########
QUERY:visit the url `url`

GENERATED (& CHOSEN) SNIPPET:
r = requests.get(url, verify=False)

SNIPPET:
import urllib

link = "http://www.somesite.com/details.pl?urn=2344"
f = urllib.urlopen(link)
myfile = f.read()
print(myfile)

SNIPPET:
import requests

link = "http://www.somesite.com/details.pl?urn=2344"
f = requests.get(link)
print(f.text)

SNIPPET:
import urllib2

data = urllib2.urlopen("http://www.google.com").read(20000) # read only 20 000 chars
data = data.split("\n") # then split it into lines

for line in data:
    print line

SNIPPET:
import webbrowser

webbrowser.open('http://example.com')  # Go to example.com

SNIPPET:
import urllib2  # the lib that handles the url stuff

data = urllib2.urlopen(target_url) # it's a file like object and works just like a file
for line in data: # files are iterable
    print line

SNIPPET:
import urllib.request  # the lib that handles the url stuff

for line in urllib.request.urlopen(target_url):
    print(line.decode('utf-8')) #utf-8 or iso8859-1 or whatever the page encoding scheme is

SNIPPET:
import urllib2

for line in urllib2.urlopen(target_url):
    print line

###########
QUERY:generate 100 random numbers

GENERATED (& CHOSEN) SNIPPET:
print(random.randrange(0, 100))

SNIPPET:
import random
my_randoms = [random.randrange(1, 101, 1) for _ in range(10)]

SNIPPET:
>>> import random
>>> random.sample(range(1, 100), 3)
[77, 52, 45]

SNIPPET:
>>> try:
...   random.sample(range(1, 2), 3)
... except ValueError:
...   print('Sample size exceeded population size.')
... 
Sample size exceeded population size

SNIPPET:
import random
my_randoms = random.sample(range(100), 10)

SNIPPET:
my_randoms = random.sample(range(1, 101), 10)

SNIPPET:
Random number:    1  2  3  4  5  6  7  8
Result:           1  2  3  4  7  8  9 10

SNIPPET:
>>> import numpy as np, numpy.random
>>> print np.random.dirichlet(np.ones(10),size=1)
[[ 0.01779975  0.14165316  0.01029262  0.168136    0.03061161  0.09046587
   0.19987289  0.13398581  0.03119906  0.17598322]]

>>> print np.random.dirichlet(np.ones(10)/1000.,size=1)
[[  2.63435230e-115   4.31961290e-209   1.41369771e-212   1.42417285e-188
    0.00000000e+000   5.79841280e-143   0.00000000e+000   9.85329725e-005
    9.99901467e-001   8.37460207e-246]]

>>> print np.random.dirichlet(np.ones(10)*1000.,size=1)
[[ 0.09967689  0.10151585  0.10077575  0.09875282  0.09935606  0.10093678
   0.09517132  0.09891358  0.10206595  0.10283501]]

###########
QUERY:generate 100 random numbers from 1 to 20

GENERATED (& CHOSEN) SNIPPET:
print(random.randint(0, 100))

SNIPPET:
import random
random.sample(range(100), 10)

SNIPPET:
>>> import random
>>> random.sample(range(1, 100), 3)
[77, 52, 45]

SNIPPET:
import random
random.uniform(0, 1)

SNIPPET:
import random
my_randoms = random.sample(range(100), 10)

SNIPPET:
all_lines = f1.readlines()
for i in range(50):
    lines = random.sample(all_lines, 40)

SNIPPET:
>>> import numpy as np, numpy.random
>>> print np.random.dirichlet(np.ones(10),size=1)
[[ 0.01779975  0.14165316  0.01029262  0.168136    0.03061161  0.09046587
   0.19987289  0.13398581  0.03119906  0.17598322]]

>>> print np.random.dirichlet(np.ones(10)/1000.,size=1)
[[  2.63435230e-115   4.31961290e-209   1.41369771e-212   1.42417285e-188
    0.00000000e+000   5.79841280e-143   0.00000000e+000   9.85329725e-005
    9.99901467e-001   8.37460207e-246]]

>>> print np.random.dirichlet(np.ones(10)*1000.,size=1)
[[ 0.09967689  0.10151585  0.10077575  0.09875282  0.09935606  0.10093678
   0.09517132  0.09891358  0.10206595  0.10283501]]

SNIPPET:
>>> try:
...   random.sample(range(1, 2), 3)
... except ValueError:
...   print('Sample size exceeded population size.')
... 
Sample size exceeded population size

###########
QUERY:create a dictionary with keys `random_letters` and values `random_numbers`

GENERATED (& CHOSEN) SNIPPET:
random_numbers = dict((key, value) for key, value in list(random_letters.
    items()))

SNIPPET:
In [1]: my_dict = {'x':1, 'y':2, 'z':3}

In [2]: dict((value, key) for key, value in my_dict.iteritems())
Out[2]: {1: 'x', 2: 'y', 3: 'z'}

SNIPPET:
import random
d = {'VENEZUELA':'CARACAS', 'CANADA':'OTTAWA'}
random.choice(list(d.values()))

SNIPPET:
country, capital = random.choice(list(d.items()))

SNIPPET:
res = dict((v,k) for k,v in a.items())

SNIPPET:
>>> my_dict = {'x':1, 'y':2, 'z':3}
>>> {v: k for k, v in my_dict.items()}
{1: 'x', 2: 'y', 3: 'z'}

SNIPPET:
res = dict((v,k) for k,v in a.iteritems())

SNIPPET:
new_dict = dict(zip(my_dict.values(), my_dict.keys()))

###########
QUERY:print `dic` keys sorted

GENERATED (& CHOSEN) SNIPPET:
print(sorted(list(dic.items()), key=k))

SNIPPET:
import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(0))

SNIPPET:
for w in sorted(d, key=d.get, reverse=True):
    print(w, d[w])

SNIPPET:
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=lambda kv: kv[1])

SNIPPET:
>>> x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
>>> {k: v for k, v in sorted(x.items(), key=lambda item: item[1])}

{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}

SNIPPET:
from collections import defaultdict
d = defaultdict(int)
for w in text.split():
    d[w] += 1

SNIPPET:
import operator
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_x = sorted(x.items(), key=operator.itemgetter(1))

SNIPPET:
import collections

sorted_dict = collections.OrderedDict(sorted_x)

###########
QUERY:print `dic` keys on each line

GENERATED (& CHOSEN) SNIPPET:
print('\n'.join(str(key) for line in dic))

SNIPPET:
for k, v in d.iteritems():
    print k, v

SNIPPET:
for key, value in mydic.items() :
    print (key, value)

SNIPPET:
for k, v in d.items():
    print(k, v)

SNIPPET:
for i in d:
    print i, d[i]

SNIPPET:
A
color : 2
speed : 70
B
color : 3
speed : 60

SNIPPET:
for x in cars:
    print (x)
    for y in cars[x]:
        print (y,':',cars[x][y])

SNIPPET:
for key, value in mydic.iteritems() :
    print key, value

###########
QUERY:read "data.csv" file

GENERATED (& CHOSEN) SNIPPET:
with open('data.csv', 'r') as f:
    pass

SNIPPET:
Data = namedtuple("Data", next(reader))

SNIPPET:
next(reader)

SNIPPET:
import csv
from collections import namedtuple
from itertools import imap

with open("data_file.txt", mode="rb") as infile:
    reader = csv.reader(infile)
    Data = namedtuple("Data", next(reader))  # get names from column headers
    for data in imap(Data._make, reader):
        print data.foo
        # ...further processing of a line...

SNIPPET:
with open('data_file.txt') as infile:
    reader = csv.DictReader(infile)
    Data = collections.namedtuple('Data', reader.fieldnames)
    tuples = [Data(**row) for row in reader]

SNIPPET:
df_iter = pd.read_csv('data.csv', chunksize=10000, iterator=True)

for iter_num, chunk in enumerate(df_iter, 1):
    print(f'Processing iteration {iter_num}')
    # do things with chunk

SNIPPET:
for chunk in pd.read_csv('data.csv', chunksize=10000):
    # do things with chunk

SNIPPET:
import csv
from collections import namedtuple

with open("data_file.txt", newline="") as infile:
    reader = csv.reader(infile)
    Data = namedtuple("Data", next(reader))  # get names from column headers
    for data in map(Data._make, reader):
        print(data.foo)
        # ...further processing of a line...

###########
QUERY:write output to csv file "output.csv"

GENERATED (& CHOSEN) SNIPPET:
output.csv.to_csv('output.csv', index=False)

SNIPPET:
print "Tmin=", ", ".join(Tmin)

SNIPPET:
print "Tmin=", Tmin[0]

SNIPPET:
writer.writerow(['Tmin']+Tmin) #note this is already printing the result to a file so dont "print" the return value

SNIPPET:
import csv
from itertools import izip_longest
from itertools import chain

data = [("key", ["value", "value"]), ("key", ["value", "value"])]

with open('somefile.csv', 'w') as file:
    output = csv.writer(file, dialect='excel-tab')
    output.writerows(
        chain.from_iterable(
            izip_longest([key], values) for key, values in data
        )
    )

SNIPPET:
key     value
        value
key     value
        value

SNIPPET:
code    info
****    ****
        ****
        ****
        ****
****    ****
        ****

SNIPPET:
import csv
with open('somefile.csv', 'w') as file:
    output = csv.writer(file, delimiter='\t')
    output.writerows([
        ['code', 'info'],
        ['****', '****'],
        [None, '****'],
        [None, '****'],
        [None, '****'],
        ['****', '****'],
        [None, '****']
    ])

###########
QUERY:write `output` to csv file

GENERATED (& CHOSEN) SNIPPET:
output.to_csv('output', index=False)

SNIPPET:
Color,Number
red,22
blue,10

SNIPPET:
df.to_csv(file_name, sep='\t', encoding='utf-8')

SNIPPET:
,Color,Number
0,red,22
1,blue,10

SNIPPET:
Color  Number
0   red     22
1  blue     10

SNIPPET:
df.to_csv(file_name, sep='\t')

SNIPPET:
##text=List of strings to be written to file
with open('csvfile.csv','wb') as file:
    for line in text:
        file.write(line)
        file.write('\n')

SNIPPET:
df.to_csv(file_name, encoding='utf-8', index=False)

###########
QUERY:search for pattern "%d%d-%d%d" in `file`

GENERATED (& CHOSEN) SNIPPET:
return re.findall('%d%d-%d%d', file)

SNIPPET:
try:
    my_abs_path = my_file.resolve(strict=True)
except FileNotFoundError:
    # doesn't exist
else:
    # exists

SNIPPET:
from pathlib import Path

my_file = Path("/path/to/file")
if my_file.is_file():
    # file exists

SNIPPET:
if my_file.exists():
    # path exists

SNIPPET:
if my_file.is_dir():
    # directory exists

SNIPPET:
os.path.isfile(file_path)

SNIPPET:
import os.path
os.path.isfile(fname)

SNIPPET:
import os.path
os.path.exists(file_path)

###########
QUERY:copy file from `src_path` to `dest_path`

GENERATED (& CHOSEN) SNIPPET:
copyfile(src_path, dest_path)

SNIPPET:
import shutil
shutil.copy('/etc/hostname', '/var/tmp/testhostname')

SNIPPET:
from shutil import copyfile
copyfile(src, dst)

SNIPPET:
import os
import shutil
src_files = os.listdir(src)
for file_name in src_files:
    full_file_name = os.path.join(src, file_name)
    if os.path.isfile(full_file_name):
        shutil.copy(full_file_name, dest)

SNIPPET:
shutil.copyfile(src_file, dest_file, *, follow_symlinks=True)

# example    
shutil.copyfile('source.txt', 'destination.txt')

SNIPPET:
┌──────────────────┬────────┬───────────┬───────┬────────────────┐
│     Function     │ Copies │   Copies  │Can use│   Destination  │
│                  │metadata│permissions│buffer │may be directory│
├──────────────────┼────────┼───────────┼───────┼────────────────┤
│shutil.copy       │   No   │    Yes    │   No  │      Yes       │
│shutil.copyfile   │   No   │     No    │   No  │       No       │
│shutil.copy2      │  Yes   │    Yes    │   No  │      Yes       │
│shutil.copyfileobj│   No   │     No    │  Yes  │       No       │
└──────────────────┴────────┴───────────┴───────┴────────────────┘

SNIPPET:
import shutil
shutil.copy2('/src/dir/file.ext', '/dst/dir/newname.ext') # complete target filename given
shutil.copy2('/src/file.ext', '/dst/dir') # target filename is /dst/dir/file.ext

SNIPPET:
import os
import shutil
import subprocess

###########
QUERY:check if `file` is a directory

GENERATED (& CHOSEN) SNIPPET:
os.path.isfile(file)

SNIPPET:
try:
    my_abs_path = my_file.resolve(strict=True)
except FileNotFoundError:
    # doesn't exist
else:
    # exists

SNIPPET:
from pathlib import Path

my_file = Path("/path/to/file")
if my_file.is_file():
    # file exists

SNIPPET:
if my_file.exists():
    # path exists

SNIPPET:
if my_file.is_dir():
    # directory exists

SNIPPET:
import os
cwd = os.getcwd()

SNIPPET:
import os.path
os.path.isfile(fname)

SNIPPET:
import os 
dir_path = os.path.dirname(os.path.realpath(__file__))

###########
QUERY:write `final_data` to csv file "price.csv"

GENERATED (& CHOSEN) SNIPPET:
final_data.to_csv('price.csv')

SNIPPET:
ID,Date,Price
0,"Jan 22, 2016",27.89
1,"Jan 21, 2016",26.80
2,"Jan 20, 2016",26.78
3,"Jan 19, 2016",26.00

SNIPPET:
['2010-06-29

SNIPPET:
import csv

date_reader = csv.reader(open('Date.csv', 'rb'))
price_reader = csv.reader(open('Price.csv', 'rb'))
writer = csv.writer(open('NewData.csv', 'wb'))
for date_row in date_reader:
    price_row = price_reader.next()
    writer.writerow(date_row + [price_row[1]])

SNIPPET:
import pandas as pd
file1 = pd.read_csv('Data.csv', index_col='ID')
file2 = pd.read_csv('Price.csv', index_col='ID')
pd.concat([file1,file2], axis=1).to_csv('Output.csv')

SNIPPET:
ID, Date, Price
0,"Jan 22, 2016",27.89
1,"Jan 21, 2016",26.80
2,"Jan 20, 2016",26.78
3,"Jan 19, 2016",26.00

SNIPPET:
with open('C:/Users/User/OneDrive/Documents/Date.csv') as file1, \
     open('C:/Users/User/OneDrive/Documents/Price.csv') as file2, \
     open('C:/Users/User/OneDrive/Documents/Output.csv', 'w') as output:
    reader1 = csv.DictReader(file1)
    reader2 = csv.DictReader(file2)
    writer = csv.DictWriter(output, ['ID', 'Date', 'Price'])
    writer.writeheader()  # Optional if you want the header

    for row1, row2 in zip(reader1, reader2):
        row1.update(row2)
        writer.writerow(row1)

SNIPPET:
csv1_dict = {  ...,
            "CompanyA productA" : 0,
            "CompanyA productB" : 0,
            ...
            }

csv2_dict = { ...,
            "CompanyA productA" : 10,
              ...
            }
for key,value in csv2_dict.iteritems():
    try:
        csv1_dict[key] = csv2_dict[key]
    except:
        #Key not in csv1

###########
QUERY:change date format

GENERATED (& CHOSEN) SNIPPET:
time.strftime('%Y-%m-%d %H:%M:%S', gmtime())

SNIPPET:
import pandas as pd

df = pd.DataFrame({'DOB': {0: '26/1/2016', 1: '26/1/2016'}})
print (df)
         DOB
0  26/1/2016 
1  26/1/2016

df['DOB'] = pd.to_datetime(df.DOB)
print (df)
         DOB
0 2016-01-26
1 2016-01-26

df['DOB1'] = df['DOB'].dt.strftime('%m/%d/%Y')
print (df)
         DOB        DOB1
0 2016-01-26  01/26/2016
1 2016-01-26  01/26/2016

SNIPPET:
>>> datetime.datetime.strptime('Mon Feb 15 2010', '%a %b %d %Y').strftime('%d/%m/%Y')
'15/02/2010'
>>>

SNIPPET:
dt = datetime.datetime.strptime("2013-1-25", '%Y-%m-%d')
print '{0}/{1}/{2:02}'.format(dt.month, dt.day, dt.year % 100)

SNIPPET:
from dateutil.parser import parse
dt = parse('Mon Feb 15 2010')
print(dt)
# datetime.datetime(2010, 2, 15, 0, 0)
print(dt.strftime('%d/%m/%Y'))
# 15/02/2010

SNIPPET:
datetime.datetime.strptime("2013-1-25", '%Y-%m-%d').strftime('%m/%d/%y')

SNIPPET:
datetime.datetime.strptime(date_string, format1).strftime(format2)

CONALA MATCH:
strftime('%Y-%m-%d %H:%M:%S', gmtime())

###########
QUERY:remove header

GENERATED (& CHOSEN) SNIPPET:
re.sub('<unk>', '', text)

SNIPPET:
print df.to_csv(index=False)
A,B
23,12
21,44
98,21

print pd.read_csv(io.StringIO(u""+df.to_csv(index=False)), header=None, skiprows=1)
    0   1
0  23  12
1  21  44
2  98  21

SNIPPET:
new_header = df.iloc[0] #grab the first row for the header
df = df[1:] #take the data less the header row
df.columns = new_header #set the header row as the df header

SNIPPET:
df.columns = df.iloc[0]
df = df[1:]

SNIPPET:
df.to_csv(path, index=False)

SNIPPET:
print df.to_csv(header=None,index=False)
23,12
21,44
98,21

print pd.read_csv(io.StringIO(u""+df.to_csv(header=None,index=False)), header=None)
    0   1
0  23  12
1  21  44
2  98  21

SNIPPET:
df.rename(columns=df.iloc[0]).drop(df.index[0])

SNIPPET:
print df.shape[1]
2

print range(df.shape[1])
[0, 1]

df.columns = range(df.shape[1])
print df
    0   1
0  23  12
1  21  44
2  98  21

###########
QUERY:timedelta

GENERATED (& CHOSEN) SNIPPET:
timedelta(hours=5) - timedelta(hours=2)

SNIPPET:
>>> import datetime
>>> datetime.timedelta(seconds=24*60*60).total_seconds()
86400.0

SNIPPET:
from datetime import datetime
def yearsago(years, from_date=None):
    if from_date is None:
        from_date = datetime.now()
    try:
        return from_date.replace(year=from_date.year - years)
    except ValueError:
        # Must be 2/29!
        assert from_date.month == 2 and from_date.day == 29 # can be removed
        return from_date.replace(month=2, day=28,
                                 year=from_date.year-years)

SNIPPET:
from dateutil.relativedelta import relativedelta

def yearsago(years, from_date=None):
    if from_date is None:
        from_date = datetime.now()
    return from_date - relativedelta(years=years)

SNIPPET:
import datetime
start = datetime.datetime(2009,2,10,14,00)
end   = datetime.datetime(2009,2,10,16,00)
delta = end-start
print(str(delta))
# prints 2:00:00

SNIPPET:
def days_hours_minutes(td):
    return td.days, td.seconds//3600, (td.seconds//60)%60

SNIPPET:
# arbitrary number of seconds
s = 13420
# hours
hours = s // 3600 
# remaining seconds
s = s - (hours * 3600)
# minutes
minutes = s // 60
# remaining seconds
seconds = s - (minutes * 60)
# total time
print '{:02}:{:02}:{:02}'.format(int(hours), int(minutes), int(seconds))
# result: 03:43:40

SNIPPET:
s = 13420
hours, remainder = divmod(s, 3600)
minutes, seconds = divmod(remainder, 60)
print '{:02}:{:02}:{:02}'.format(int(hours), int(minutes), int(seconds))
# result: 03:43:40

###########
QUERY:time and date in certain

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.combine(datetime.datetime.now(), datetime.datetime.now() +
    datetime.timedelta(days=1))

SNIPPET:
from datetime import datetime
datetime.now().strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
base = datetime.datetime.today()
date_list = [base - datetime.timedelta(days=x) for x in range(numdays)]

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
>>> from datetime import datetime
>>> str(datetime.now())
'2011-05-03 17:45:35.177000'

CONALA MATCH:
datetime.datetime.now()

###########
QUERY:convert text file encoding

GENERATED (& CHOSEN) SNIPPET:
print(codecs.open('file.txt', 'w', encoding='utf-8').decode('utf-8'))

SNIPPET:
f = file('test', 'r')
print f.read().decode('utf8')

SNIPPET:
>>> print u'\u2019'
’
>>> unicodedata.name(u'\u2019')
'RIGHT SINGLE QUOTATION MARK'
>>> u'\u2019'.encode('ascii', 'ignore')
''
# Note we get an empty string back
>>> u'\u2019'.replace(u'\u2019', u'\'').encode('ascii', 'ignore')
"'"

SNIPPET:
>>> u'aあä'.encode('ascii', 'replace')
b'a??'
>>> u'aあä'.encode('ascii', 'xmlcharrefreplace')
b'a&#12354;&#228;'
>>> u'aあä'.encode('ascii', 'backslashreplace')
b'a\\u3042\\xe4'

SNIPPET:
>>> u'aあä'.encode('ascii', 'ignore')
'a'

SNIPPET:
foo = u'Δ, Й, ק, ‎ م, ๗, あ, 叶, 葉, and 말.'
f = open('test', 'w')
f.write(foo.encode('utf8'))
f.close()

SNIPPET:
>>> import unicodedata
>>> unicodedata.normalize('NFKD', u'aあä').encode('ascii', 'ignore')
'aa'

###########
QUERY:convert list to dictionary

GENERATED (& CHOSEN) SNIPPET:
dict((k, ':') for k, v in list(d.items()))

SNIPPET:
b = {a[i]: a[i+1] for i in range(0, len(a), 2)}

SNIPPET:
l = ["a", "b", "c", "d", "e"]

SNIPPET:
b = dict(zip(a[::2], a[1::2]))

SNIPPET:
dict(one=1, two=2)
dict({'one': 1, 'two': 2})
dict(zip(('one', 'two'), (1, 2)))
dict([['two', 2], ['one', 1]])

SNIPPET:
i = iter(a)
b = dict(zip(i, i))

SNIPPET:
from itertools import izip
i = iter(a)
b = dict(izip(i, i))

SNIPPET:
l = [["a", "b"], ["c", "d"], ["e",]]

CONALA MATCH:
list(d.items())

CONALA MATCH:
list(d.items())

###########
QUERY:get the date and time a week from now in gmt

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.now().strftime('%a')

SNIPPET:
from datetime import datetime
datetime.now().strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
>>> import datetime
>>> datetime.date(2010, 6, 16).isocalendar()[1]
24

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
>>> from datetime import datetime
>>> str(datetime.now())
'2011-05-03 17:45:35.177000'

CONALA MATCH:
datetime.datetime.now().strftime('%a')

CONALA EXACT MATCH:
datetime.datetime.now().strftime('%a')

CONALA MATCH:
datetime.datetime.now()

###########
QUERY:get date and time in gmt

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.combine(datetime.date.today(), datetime.date.utcnow())

SNIPPET:
from datetime import datetime
datetime.now().strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
import time

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
>>> from datetime import datetime
>>> str(datetime.now())
'2011-05-03 17:45:35.177000'

###########
QUERY:get time and date in gmt in `date`

GENERATED (& CHOSEN) SNIPPET:
datetime.datetime.combine(date, datetime.time())

SNIPPET:
from datetime import datetime
datetime.now().strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
import time

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
>>> from datetime import datetime
>>> str(datetime.now())
'2011-05-03 17:45:35.177000'

###########
QUERY:get the current date in utc

GENERATED (& CHOSEN) SNIPPET:
today = datetime.datetime.utcnow().date()

SNIPPET:
from datetime import datetime
datetime.now().strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
import time

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
>>> from datetime import datetime
>>> str(datetime.now())
'2011-05-03 17:45:35.177000'

CONALA MATCH:
today = datetime.datetime.utcnow().date()

CONALA EXACT MATCH:
today = datetime.datetime.utcnow().date()

CONALA MATCH:
datetime.utcnow()

###########
QUERY:get the current time in utc

GENERATED (& CHOSEN) SNIPPET:
now = datetime.datetime.utcnow().date()

SNIPPET:
from datetime import datetime
datetime.now().strftime('%Y-%m-%d %H:%M:%S')

SNIPPET:
>>> from datetime import datetime

SNIPPET:
>>> datetime.datetime.now().time()
datetime.time(15, 8, 24, 78915)

>>> print(datetime.datetime.now().time())
15:08:24.789150

SNIPPET:
from datetime import datetime
from dateutil import tz

# METHOD 1: Hardcode zones:
from_zone = tz.gettz('UTC')
to_zone = tz.gettz('America/New_York')

# METHOD 2: Auto-detect zones:
from_zone = tz.tzutc()
to_zone = tz.tzlocal()

# utc = datetime.utcnow()
utc = datetime.strptime('2011-01-21 02:37:21', '%Y-%m-%d %H:%M:%S')

# Tell the datetime object that it's in UTC time zone since 
# datetime objects are 'naive' by default
utc = utc.replace(tzinfo=from_zone)

# Convert time zone
central = utc.astimezone(to_zone)

SNIPPET:
>>> from time import gmtime, strftime
>>> strftime("%Y-%m-%d %H:%M:%S", gmtime())
'2009-01-05 22:14:39'

SNIPPET:
>>> import datetime
>>> datetime.datetime.now()
datetime.datetime(2009, 1, 6, 15, 8, 24, 78915)

>>> print(datetime.datetime.now())
2009-01-06 15:08:24.789150

SNIPPET:
>>> from datetime import datetime
>>> str(datetime.now())
'2011-05-03 17:45:35.177000'

CONALA MATCH:
datetime.utcnow()

###########
QUERY:open csv file with read and write

GENERATED (& CHOSEN) SNIPPET:
pd.read_csv('file', shell=True)

SNIPPET:
import csv

# Define data
data = [
    (1, "A towel,", 1.0),
    (42, " it says, ", 2.0),
    (1337, "is about the most ", -1),
    (0, "massively useful thing ", 123),
    (-2, "an interstellar hitchhiker can have.", 3),
]

# Write CSV file
with open("test.csv", "wt") as fp:
    writer = csv.writer(fp, delimiter=",")
    # writer.writerow(["your", "header", "foo"])  # write header
    writer.writerows(data)

# Read CSV file
with open("test.csv") as fp:
    reader = csv.reader(fp, delimiter=",", quotechar='"')
    # next(reader, None)  # skip the headers
    data_read = [row for row in reader]

print(data_read)

SNIPPET:
[['1', 'A towel,', '1.0'],
 ['42', ' it says, ', '2.0'],
 ['1337', 'is about the most ', '-1'],
 ['0', 'massively useful thing ', '123'],
 ['-2', 'an interstellar hitchhiker can have.', '3']]

SNIPPET:
import os

if os.path.exists(fName):
   with open(fName, 'rb') as f:
       try:
           # do stuff
       except : # whatever reader errors you care about
           # handle error

SNIPPET:
import pandas as pd

# Read the CSV into a pandas data frame (df)
#   With a df you can do many things
#   most important: visualize data with Seaborn
df = pd.read_csv('myfile.csv', sep=',')
print(df)

# Or export it in many ways, e.g. a list of tuples
tuples = [tuple(x) for x in df.values]

# or export it as a list of dicts
dicts = df.to_dict().values()

SNIPPET:
try:
    f = open(fname, 'rb')
except OSError:
    print "Could not open/read file:", fname
    sys.exit()

with f:
    reader = csv.reader(f)
    for row in reader:
        pass #do stuff here

SNIPPET:
import mpu.io
data = mpu.io.read('example.csv', delimiter=',', quotechar='"', skiprows=None)
mpu.io.write('example.csv', data)

SNIPPET:
1,"A towel,",1.0
42," it says, ",2.0
1337,is about the most ,-1
0,massively useful thing ,123
-2,an interstellar hitchhiker can have.,3

###########
QUERY:open csv file `data.csv`

GENERATED (& CHOSEN) SNIPPET:
df = pd.read_csv('data.csv', sep=',', header=None)

SNIPPET:
import csv

# Define data
data = [
    (1, "A towel,", 1.0),
    (42, " it says, ", 2.0),
    (1337, "is about the most ", -1),
    (0, "massively useful thing ", 123),
    (-2, "an interstellar hitchhiker can have.", 3),
]

# Write CSV file
with open("test.csv", "wt") as fp:
    writer = csv.writer(fp, delimiter=",")
    # writer.writerow(["your", "header", "foo"])  # write header
    writer.writerows(data)

# Read CSV file
with open("test.csv") as fp:
    reader = csv.reader(fp, delimiter=",", quotechar='"')
    # next(reader, None)  # skip the headers
    data_read = [row for row in reader]

print(data_read)

SNIPPET:
f = open('foo.csv', 'wb')
w = csv.writer(f)

SNIPPET:
[['1', 'A towel,', '1.0'],
 ['42', ' it says, ', '2.0'],
 ['1337', 'is about the most ', '-1'],
 ['0', 'massively useful thing ', '123'],
 ['-2', 'an interstellar hitchhiker can have.', '3']]

SNIPPET:
import pandas as pd

# Read the CSV into a pandas data frame (df)
#   With a df you can do many things
#   most important: visualize data with Seaborn
df = pd.read_csv('myfile.csv', sep=',')
print(df)

# Or export it in many ways, e.g. a list of tuples
tuples = [tuple(x) for x in df.values]

# or export it as a list of dicts
dicts = df.to_dict().values()

SNIPPET:
w = csv.writer(open('foo.csv', 'wb'))

SNIPPET:
import mpu.io
data = mpu.io.read('example.csv', delimiter=',', quotechar='"', skiprows=None)
mpu.io.write('example.csv', data)

SNIPPET:
1,"A towel,",1.0
42," it says, ",2.0
1337,is about the most ,-1
0,massively useful thing ,123
-2,an interstellar hitchhiker can have.,3

###########
QUERY:read a csv file

GENERATED (& CHOSEN) SNIPPET:
df = pd.read_csv('<unk>', quotechar=',')

SNIPPET:
import csv

# Define data
data = [
    (1, "A towel,", 1.0),
    (42, " it says, ", 2.0),
    (1337, "is about the most ", -1),
    (0, "massively useful thing ", 123),
    (-2, "an interstellar hitchhiker can have.", 3),
]

# Write CSV file
with open("test.csv", "wt") as fp:
    writer = csv.writer(fp, delimiter=",")
    # writer.writerow(["your", "header", "foo"])  # write header
    writer.writerows(data)

# Read CSV file
with open("test.csv") as fp:
    reader = csv.reader(fp, delimiter=",", quotechar='"')
    # next(reader, None)  # skip the headers
    data_read = [row for row in reader]

print(data_read)

SNIPPET:
[['1', 'A towel,', '1.0'],
 ['42', ' it says, ', '2.0'],
 ['1337', 'is about the most ', '-1'],
 ['0', 'massively useful thing ', '123'],
 ['-2', 'an interstellar hitchhiker can have.', '3']]

SNIPPET:
for row in getdata(somefilename, sequence_of_criteria):
    # process row

SNIPPET:
def getdata(filename, criteria):
    for criterion in criteria:
        for row in getstuff(filename, criterion):
            yield row

SNIPPET:
import csv

def getstuff(filename, criterion):
    with open(filename, "rb") as csvfile:
        datareader = csv.reader(csvfile)
        yield next(datareader)  # yield the header row
        count = 0
        for row in datareader:
            if row[3] == criterion:
                yield row
                count += 1
            elif count:
                # done when having read a consecutive series of rows 
                return

SNIPPET:
import mpu.io
data = mpu.io.read('example.csv', delimiter=',', quotechar='"', skiprows=None)
mpu.io.write('example.csv', data)

SNIPPET:
import csv
from itertools import dropwhile, takewhile

def getstuff(filename, criterion):
    with open(filename, "rb") as csvfile:
        datareader = csv.reader(csvfile)
        yield next(datareader)  # yield the header row
        # first row, plus any subsequent rows that match, then stop
        # reading altogether
        # Python 2: use `for row in takewhile(...): yield row` instead
        # instead of `yield from takewhile(...)`.
        yield from takewhile(
            lambda r: r[3] == criterion,
            dropwhile(lambda r: r[3] != criterion, datareader))
        return

###########
NUM UNIQUE QUERY-SNIPPET PAIRS IN candidate_lengths.csv:435
NUM UNIQUE QUERIES IN candidate_lengths.csv: 409
NUM QUERIES:404
NUM INTERESTING:173
NUM MATCHES:6
CONALA TRAIN:2379
NUM CONALA MATCHES:27
NUM CONALA EXACT MATCHES:13
